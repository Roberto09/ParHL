Grammar:

Rule 0     S' -> globals
Rule 1     globals -> ignored_newlines globals_aux
Rule 2     globals_aux -> empty
Rule 3     globals_aux -> statements
Rule 4     globals_aux -> statement globals_aux
Rule 5     const -> STRING_V
Rule 6     const -> BOOL_V
Rule 7     const -> FLOAT_V
Rule 8     const -> INT_V
Rule 9     tens -> L_BRACKET expr tens_1
Rule 10    tens_1 -> COMMA expr tens_1
Rule 11    tens_1 -> R_BRACKET
Rule 12    tens_id -> tens_id L_BRACKET expr R_BRACKET
Rule 13    tens_id -> ID L_BRACKET expr R_BRACKET
Rule 14    block -> ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines
Rule 15    block_1 -> empty
Rule 16    block_1 -> statement block_1
Rule 17    const_type -> GPU_BOOL_T
Rule 18    const_type -> GPU_FLOAT_T
Rule 19    const_type -> GPU_INT_T
Rule 20    const_type -> BOOL_T
Rule 21    const_type -> STRING_T
Rule 22    const_type -> FLOAT_T
Rule 23    const_type -> INT_T
Rule 24    expr -> t_expr OR expr
Rule 25    expr -> t_expr
Rule 26    t_expr -> g_expr AND t_expr
Rule 27    t_expr -> g_expr
Rule 28    g_expr -> m_expr comparison m_expr
Rule 29    g_expr -> m_expr
Rule 30    comparison -> LEQT
Rule 31    comparison -> GEQT
Rule 32    comparison -> LT
Rule 33    comparison -> GT
Rule 34    comparison -> NOT_EQ
Rule 35    comparison -> EQ
Rule 36    m_expr -> term MINUS m_expr
Rule 37    m_expr -> term PLUS m_expr
Rule 38    m_expr -> term
Rule 39    term -> exp_factor MOD term
Rule 40    term -> exp_factor DIV term
Rule 41    term -> exp_factor MULT term
Rule 42    term -> exp_factor
Rule 43    exp_factor -> factor EXP exp_factor
Rule 44    exp_factor -> factor
Rule 45    factor -> MINUS factor_1
Rule 46    factor -> PLUS factor_1
Rule 47    factor -> NOT factor_1
Rule 48    factor -> factor_1
Rule 49    factor_1 -> ID
Rule 50    factor_1 -> read_file
Rule 51    factor_1 -> read_line
Rule 52    factor_1 -> tens_id
Rule 53    factor_1 -> tens
Rule 54    factor_1 -> func_call
Rule 55    factor_1 -> const
Rule 56    factor_1 -> L_PAREN expr R_PAREN
Rule 57    read_line -> READ_LINE L_PAREN R_PAREN
Rule 58    print_rule -> PRINT L_PAREN func_call_1
Rule 59    read_file -> READ_FILE L_PAREN expr R_PAREN
Rule 60    write_file -> WRITE_FILE L_PAREN func_call_1
Rule 61    func_call -> ID L_PAREN func_call_1
Rule 62    func_call_1 -> expr COMMA func_call_1
Rule 63    func_call_1 -> expr R_PAREN
Rule 64    func_call_1 -> R_PAREN
Rule 65    assign -> ID ASSIG expr
Rule 66    var -> LET var_1
Rule 67    var_1 -> var_2 COMMA var_1
Rule 68    var_1 -> var_2
Rule 69    var_2 -> var_3 ASSIG expr
Rule 70    var_2 -> var_3
Rule 71    var_3 -> var_id COLON const_type
Rule 72    var_id -> var_id L_BRACKET INT_V R_BRACKET
Rule 73    var_id -> ID
Rule 74    while_loop -> WHILE L_PAREN expr R_PAREN block
Rule 75    for_loop -> FOR L_PAREN var SEMICOLON expr SEMICOLON assign R_PAREN block
Rule 76    cond -> cond_if_else_if
Rule 77    cond -> cond_if_else
Rule 78    cond -> cond_if
Rule 79    simple_if -> IF L_PAREN expr R_PAREN block
Rule 80    simple_else -> ELSE block
Rule 81    simple_else_if -> ELSE_IF L_PAREN expr R_PAREN block complex_else_if
Rule 82    complex_else_if -> empty
Rule 83    complex_else_if -> simple_else_if
Rule 84    cond_if -> simple_if
Rule 85    cond_if_else -> simple_if simple_else
Rule 86    cond_if_else_if -> simple_if simple_else_if simple_else
Rule 87    cond_if_else_if -> simple_if simple_else_if
Rule 88    func -> LET ID L_PAREN func_params R_PAREN COLON func_type block
Rule 89    func_params -> empty
Rule 90    func_params -> func_params_1
Rule 91    func_params_1 -> ID COLON const_type COMMA func_params_1
Rule 92    func_params_1 -> ID COLON const_type
Rule 93    func_type -> VOID
Rule 94    func_type -> const_type
Rule 95    ret -> RETURN expr
Rule 96    statement -> block_statements
Rule 97    statement -> statements eos
Rule 98    statements -> ret
Rule 99    statements -> func_call
Rule 100   statements -> write_file
Rule 101   statements -> print_rule
Rule 102   statements -> assign
Rule 103   statements -> var
Rule 104   block_statements -> func
Rule 105   block_statements -> cond
Rule 106   block_statements -> for_loop
Rule 107   block_statements -> while_loop
Rule 108   eos -> NEWLINE ignored_newlines
Rule 109   eos -> SEMICOLON ignored_newlines
Rule 110   ignored_newlines -> empty
Rule 111   ignored_newlines -> NEWLINE ignored_newlines
Rule 112   empty -> <empty>

Terminals, with rules where they appear:

AND                  : 26
ASSIG                : 65 69
BOOL_T               : 20
BOOL_V               : 6
COLON                : 71 88 91 92
COMMA                : 10 62 67 91
DIV                  : 40
ELSE                 : 80
ELSE_IF              : 81
EQ                   : 35
EXP                  : 43
FLOAT_T              : 22
FLOAT_V              : 7
FOR                  : 75
GEQT                 : 31
GPU_BOOL_T           : 17
GPU_FLOAT_T          : 18
GPU_INT_T            : 19
GT                   : 33
ID                   : 13 49 61 65 73 88 91 92
IF                   : 79
INT_T                : 23
INT_V                : 8 72
LEQT                 : 30
LET                  : 66 88
LT                   : 32
L_BRACE              : 14
L_BRACKET            : 9 12 13 72
L_PAREN              : 56 57 58 59 60 61 74 75 79 81 88
MINUS                : 36 45
MOD                  : 39
MULT                 : 41
NEWLINE              : 108 111
NOT                  : 47
NOT_EQ               : 34
OR                   : 24
PLUS                 : 37 46
PRINT                : 58
READ_FILE            : 59
READ_LINE            : 57
RETURN               : 95
R_BRACE              : 14
R_BRACKET            : 11 12 13 72
R_PAREN              : 56 57 59 63 64 74 75 79 81 88
SEMICOLON            : 75 75 109
STRING_T             : 21
STRING_V             : 5
VOID                 : 93
WHILE                : 74
WRITE_FILE           : 60
error                : 

Nonterminals, with rules where they appear:

assign               : 75 102
block                : 74 75 79 80 81 88
block_1              : 14 16
block_statements     : 96
comparison           : 28
complex_else_if      : 81
cond                 : 105
cond_if              : 78
cond_if_else         : 77
cond_if_else_if      : 76
const                : 55
const_type           : 71 91 92 94
empty                : 2 15 82 89 110
eos                  : 97
exp_factor           : 39 40 41 42 43
expr                 : 9 10 12 13 24 56 59 62 63 65 69 74 75 79 81 95
factor               : 43 44
factor_1             : 45 46 47 48
for_loop             : 106
func                 : 104
func_call            : 54 99
func_call_1          : 58 60 61 62
func_params          : 88
func_params_1        : 90 91
func_type            : 88
g_expr               : 26 27
globals              : 0
globals_aux          : 1 4
ignored_newlines     : 1 14 14 14 108 109 111
m_expr               : 28 28 29 36 37
print_rule           : 101
read_file            : 50
read_line            : 51
ret                  : 98
simple_else          : 85 86
simple_else_if       : 83 86 87
simple_if            : 84 85 86 87
statement            : 4 16
statements           : 3 97
t_expr               : 24 25 26
tens                 : 53
tens_1               : 9 10
tens_id              : 12 52
term                 : 36 37 38 39 40 41
var                  : 75 103
var_1                : 66 67
var_2                : 67 68
var_3                : 69 70
var_id               : 71 72
while_loop           : 107
write_file           : 100


state 0

    (0) S' -> . globals
    (1) globals -> . ignored_newlines globals_aux
    (110) ignored_newlines -> . empty
    (111) ignored_newlines -> . NEWLINE ignored_newlines
    (112) empty -> .
    NEWLINE         shift and go to state 4
    RETURN          reduce using rule 112 (empty -> .)
    ID              reduce using rule 112 (empty -> .)
    WRITE_FILE      reduce using rule 112 (empty -> .)
    PRINT           reduce using rule 112 (empty -> .)
    LET             reduce using rule 112 (empty -> .)
    FOR             reduce using rule 112 (empty -> .)
    WHILE           reduce using rule 112 (empty -> .)
    IF              reduce using rule 112 (empty -> .)
    $end            reduce using rule 112 (empty -> .)

    globals                        shift and go to state 1
    ignored_newlines               shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> globals .


state 2

    (1) globals -> ignored_newlines . globals_aux
    (2) globals_aux -> . empty
    (3) globals_aux -> . statements
    (4) globals_aux -> . statement globals_aux
    (112) empty -> .
    (98) statements -> . ret
    (99) statements -> . func_call
    (100) statements -> . write_file
    (101) statements -> . print_rule
    (102) statements -> . assign
    (103) statements -> . var
    (96) statement -> . block_statements
    (97) statement -> . statements eos
    (95) ret -> . RETURN expr
    (61) func_call -> . ID L_PAREN func_call_1
    (60) write_file -> . WRITE_FILE L_PAREN func_call_1
    (58) print_rule -> . PRINT L_PAREN func_call_1
    (65) assign -> . ID ASSIG expr
    (66) var -> . LET var_1
    (104) block_statements -> . func
    (105) block_statements -> . cond
    (106) block_statements -> . for_loop
    (107) block_statements -> . while_loop
    (88) func -> . LET ID L_PAREN func_params R_PAREN COLON func_type block
    (76) cond -> . cond_if_else_if
    (77) cond -> . cond_if_else
    (78) cond -> . cond_if
    (75) for_loop -> . FOR L_PAREN var SEMICOLON expr SEMICOLON assign R_PAREN block
    (74) while_loop -> . WHILE L_PAREN expr R_PAREN block
    (86) cond_if_else_if -> . simple_if simple_else_if simple_else
    (87) cond_if_else_if -> . simple_if simple_else_if
    (85) cond_if_else -> . simple_if simple_else
    (84) cond_if -> . simple_if
    (79) simple_if -> . IF L_PAREN expr R_PAREN block
    $end            reduce using rule 112 (empty -> .)
    RETURN          shift and go to state 16
    ID              shift and go to state 17
    WRITE_FILE      shift and go to state 18
    PRINT           shift and go to state 19
    LET             shift and go to state 20
    FOR             shift and go to state 28
    WHILE           shift and go to state 29
    IF              shift and go to state 31

    globals_aux                    shift and go to state 5
    empty                          shift and go to state 6
    statements                     shift and go to state 7
    statement                      shift and go to state 8
    ret                            shift and go to state 9
    func_call                      shift and go to state 10
    write_file                     shift and go to state 11
    print_rule                     shift and go to state 12
    assign                         shift and go to state 13
    var                            shift and go to state 14
    block_statements               shift and go to state 15
    func                           shift and go to state 21
    cond                           shift and go to state 22
    for_loop                       shift and go to state 23
    while_loop                     shift and go to state 24
    cond_if_else_if                shift and go to state 25
    cond_if_else                   shift and go to state 26
    cond_if                        shift and go to state 27
    simple_if                      shift and go to state 30

state 3

    (110) ignored_newlines -> empty .
    RETURN          reduce using rule 110 (ignored_newlines -> empty .)
    ID              reduce using rule 110 (ignored_newlines -> empty .)
    WRITE_FILE      reduce using rule 110 (ignored_newlines -> empty .)
    PRINT           reduce using rule 110 (ignored_newlines -> empty .)
    LET             reduce using rule 110 (ignored_newlines -> empty .)
    FOR             reduce using rule 110 (ignored_newlines -> empty .)
    WHILE           reduce using rule 110 (ignored_newlines -> empty .)
    IF              reduce using rule 110 (ignored_newlines -> empty .)
    $end            reduce using rule 110 (ignored_newlines -> empty .)
    R_BRACE         reduce using rule 110 (ignored_newlines -> empty .)
    L_BRACE         reduce using rule 110 (ignored_newlines -> empty .)
    ELSE_IF         reduce using rule 110 (ignored_newlines -> empty .)
    ELSE            reduce using rule 110 (ignored_newlines -> empty .)


state 4

    (111) ignored_newlines -> NEWLINE . ignored_newlines
    (110) ignored_newlines -> . empty
    (111) ignored_newlines -> . NEWLINE ignored_newlines
    (112) empty -> .
    NEWLINE         shift and go to state 4
    RETURN          reduce using rule 112 (empty -> .)
    ID              reduce using rule 112 (empty -> .)
    WRITE_FILE      reduce using rule 112 (empty -> .)
    PRINT           reduce using rule 112 (empty -> .)
    LET             reduce using rule 112 (empty -> .)
    FOR             reduce using rule 112 (empty -> .)
    WHILE           reduce using rule 112 (empty -> .)
    IF              reduce using rule 112 (empty -> .)
    $end            reduce using rule 112 (empty -> .)
    R_BRACE         reduce using rule 112 (empty -> .)
    L_BRACE         reduce using rule 112 (empty -> .)
    ELSE_IF         reduce using rule 112 (empty -> .)
    ELSE            reduce using rule 112 (empty -> .)

    ignored_newlines               shift and go to state 32
    empty                          shift and go to state 3

state 5

    (1) globals -> ignored_newlines globals_aux .
    $end            reduce using rule 1 (globals -> ignored_newlines globals_aux .)


state 6

    (2) globals_aux -> empty .
    $end            reduce using rule 2 (globals_aux -> empty .)


state 7

    (3) globals_aux -> statements .
    (97) statement -> statements . eos
    (108) eos -> . NEWLINE ignored_newlines
    (109) eos -> . SEMICOLON ignored_newlines
    $end            reduce using rule 3 (globals_aux -> statements .)
    NEWLINE         shift and go to state 34
    SEMICOLON       shift and go to state 35

    eos                            shift and go to state 33

state 8

    (4) globals_aux -> statement . globals_aux
    (2) globals_aux -> . empty
    (3) globals_aux -> . statements
    (4) globals_aux -> . statement globals_aux
    (112) empty -> .
    (98) statements -> . ret
    (99) statements -> . func_call
    (100) statements -> . write_file
    (101) statements -> . print_rule
    (102) statements -> . assign
    (103) statements -> . var
    (96) statement -> . block_statements
    (97) statement -> . statements eos
    (95) ret -> . RETURN expr
    (61) func_call -> . ID L_PAREN func_call_1
    (60) write_file -> . WRITE_FILE L_PAREN func_call_1
    (58) print_rule -> . PRINT L_PAREN func_call_1
    (65) assign -> . ID ASSIG expr
    (66) var -> . LET var_1
    (104) block_statements -> . func
    (105) block_statements -> . cond
    (106) block_statements -> . for_loop
    (107) block_statements -> . while_loop
    (88) func -> . LET ID L_PAREN func_params R_PAREN COLON func_type block
    (76) cond -> . cond_if_else_if
    (77) cond -> . cond_if_else
    (78) cond -> . cond_if
    (75) for_loop -> . FOR L_PAREN var SEMICOLON expr SEMICOLON assign R_PAREN block
    (74) while_loop -> . WHILE L_PAREN expr R_PAREN block
    (86) cond_if_else_if -> . simple_if simple_else_if simple_else
    (87) cond_if_else_if -> . simple_if simple_else_if
    (85) cond_if_else -> . simple_if simple_else
    (84) cond_if -> . simple_if
    (79) simple_if -> . IF L_PAREN expr R_PAREN block
    $end            reduce using rule 112 (empty -> .)
    RETURN          shift and go to state 16
    ID              shift and go to state 17
    WRITE_FILE      shift and go to state 18
    PRINT           shift and go to state 19
    LET             shift and go to state 20
    FOR             shift and go to state 28
    WHILE           shift and go to state 29
    IF              shift and go to state 31

    statement                      shift and go to state 8
    globals_aux                    shift and go to state 36
    empty                          shift and go to state 6
    statements                     shift and go to state 7
    ret                            shift and go to state 9
    func_call                      shift and go to state 10
    write_file                     shift and go to state 11
    print_rule                     shift and go to state 12
    assign                         shift and go to state 13
    var                            shift and go to state 14
    block_statements               shift and go to state 15
    func                           shift and go to state 21
    cond                           shift and go to state 22
    for_loop                       shift and go to state 23
    while_loop                     shift and go to state 24
    cond_if_else_if                shift and go to state 25
    cond_if_else                   shift and go to state 26
    cond_if                        shift and go to state 27
    simple_if                      shift and go to state 30

state 9

    (98) statements -> ret .
    NEWLINE         reduce using rule 98 (statements -> ret .)
    SEMICOLON       reduce using rule 98 (statements -> ret .)
    $end            reduce using rule 98 (statements -> ret .)


state 10

    (99) statements -> func_call .
    NEWLINE         reduce using rule 99 (statements -> func_call .)
    SEMICOLON       reduce using rule 99 (statements -> func_call .)
    $end            reduce using rule 99 (statements -> func_call .)


state 11

    (100) statements -> write_file .
    NEWLINE         reduce using rule 100 (statements -> write_file .)
    SEMICOLON       reduce using rule 100 (statements -> write_file .)
    $end            reduce using rule 100 (statements -> write_file .)


state 12

    (101) statements -> print_rule .
    NEWLINE         reduce using rule 101 (statements -> print_rule .)
    SEMICOLON       reduce using rule 101 (statements -> print_rule .)
    $end            reduce using rule 101 (statements -> print_rule .)


state 13

    (102) statements -> assign .
    NEWLINE         reduce using rule 102 (statements -> assign .)
    SEMICOLON       reduce using rule 102 (statements -> assign .)
    $end            reduce using rule 102 (statements -> assign .)


state 14

    (103) statements -> var .
    NEWLINE         reduce using rule 103 (statements -> var .)
    SEMICOLON       reduce using rule 103 (statements -> var .)
    $end            reduce using rule 103 (statements -> var .)


state 15

    (96) statement -> block_statements .
    RETURN          reduce using rule 96 (statement -> block_statements .)
    ID              reduce using rule 96 (statement -> block_statements .)
    WRITE_FILE      reduce using rule 96 (statement -> block_statements .)
    PRINT           reduce using rule 96 (statement -> block_statements .)
    LET             reduce using rule 96 (statement -> block_statements .)
    FOR             reduce using rule 96 (statement -> block_statements .)
    WHILE           reduce using rule 96 (statement -> block_statements .)
    IF              reduce using rule 96 (statement -> block_statements .)
    $end            reduce using rule 96 (statement -> block_statements .)
    R_BRACE         reduce using rule 96 (statement -> block_statements .)


state 16

    (95) ret -> RETURN . expr
    (24) expr -> . t_expr OR expr
    (25) expr -> . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    expr                           shift and go to state 37
    t_expr                         shift and go to state 38
    g_expr                         shift and go to state 39
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 17

    (61) func_call -> ID . L_PAREN func_call_1
    (65) assign -> ID . ASSIG expr
    L_PAREN         shift and go to state 63
    ASSIG           shift and go to state 64


state 18

    (60) write_file -> WRITE_FILE . L_PAREN func_call_1
    L_PAREN         shift and go to state 65


state 19

    (58) print_rule -> PRINT . L_PAREN func_call_1
    L_PAREN         shift and go to state 66


state 20

    (66) var -> LET . var_1
    (88) func -> LET . ID L_PAREN func_params R_PAREN COLON func_type block
    (67) var_1 -> . var_2 COMMA var_1
    (68) var_1 -> . var_2
    (69) var_2 -> . var_3 ASSIG expr
    (70) var_2 -> . var_3
    (71) var_3 -> . var_id COLON const_type
    (72) var_id -> . var_id L_BRACKET INT_V R_BRACKET
    (73) var_id -> . ID
    ID              shift and go to state 68

    var_1                          shift and go to state 67
    var_2                          shift and go to state 69
    var_3                          shift and go to state 70
    var_id                         shift and go to state 71

state 21

    (104) block_statements -> func .
    RETURN          reduce using rule 104 (block_statements -> func .)
    ID              reduce using rule 104 (block_statements -> func .)
    WRITE_FILE      reduce using rule 104 (block_statements -> func .)
    PRINT           reduce using rule 104 (block_statements -> func .)
    LET             reduce using rule 104 (block_statements -> func .)
    FOR             reduce using rule 104 (block_statements -> func .)
    WHILE           reduce using rule 104 (block_statements -> func .)
    IF              reduce using rule 104 (block_statements -> func .)
    $end            reduce using rule 104 (block_statements -> func .)
    R_BRACE         reduce using rule 104 (block_statements -> func .)


state 22

    (105) block_statements -> cond .
    RETURN          reduce using rule 105 (block_statements -> cond .)
    ID              reduce using rule 105 (block_statements -> cond .)
    WRITE_FILE      reduce using rule 105 (block_statements -> cond .)
    PRINT           reduce using rule 105 (block_statements -> cond .)
    LET             reduce using rule 105 (block_statements -> cond .)
    FOR             reduce using rule 105 (block_statements -> cond .)
    WHILE           reduce using rule 105 (block_statements -> cond .)
    IF              reduce using rule 105 (block_statements -> cond .)
    $end            reduce using rule 105 (block_statements -> cond .)
    R_BRACE         reduce using rule 105 (block_statements -> cond .)


state 23

    (106) block_statements -> for_loop .
    RETURN          reduce using rule 106 (block_statements -> for_loop .)
    ID              reduce using rule 106 (block_statements -> for_loop .)
    WRITE_FILE      reduce using rule 106 (block_statements -> for_loop .)
    PRINT           reduce using rule 106 (block_statements -> for_loop .)
    LET             reduce using rule 106 (block_statements -> for_loop .)
    FOR             reduce using rule 106 (block_statements -> for_loop .)
    WHILE           reduce using rule 106 (block_statements -> for_loop .)
    IF              reduce using rule 106 (block_statements -> for_loop .)
    $end            reduce using rule 106 (block_statements -> for_loop .)
    R_BRACE         reduce using rule 106 (block_statements -> for_loop .)


state 24

    (107) block_statements -> while_loop .
    RETURN          reduce using rule 107 (block_statements -> while_loop .)
    ID              reduce using rule 107 (block_statements -> while_loop .)
    WRITE_FILE      reduce using rule 107 (block_statements -> while_loop .)
    PRINT           reduce using rule 107 (block_statements -> while_loop .)
    LET             reduce using rule 107 (block_statements -> while_loop .)
    FOR             reduce using rule 107 (block_statements -> while_loop .)
    WHILE           reduce using rule 107 (block_statements -> while_loop .)
    IF              reduce using rule 107 (block_statements -> while_loop .)
    $end            reduce using rule 107 (block_statements -> while_loop .)
    R_BRACE         reduce using rule 107 (block_statements -> while_loop .)


state 25

    (76) cond -> cond_if_else_if .
    RETURN          reduce using rule 76 (cond -> cond_if_else_if .)
    ID              reduce using rule 76 (cond -> cond_if_else_if .)
    WRITE_FILE      reduce using rule 76 (cond -> cond_if_else_if .)
    PRINT           reduce using rule 76 (cond -> cond_if_else_if .)
    LET             reduce using rule 76 (cond -> cond_if_else_if .)
    FOR             reduce using rule 76 (cond -> cond_if_else_if .)
    WHILE           reduce using rule 76 (cond -> cond_if_else_if .)
    IF              reduce using rule 76 (cond -> cond_if_else_if .)
    $end            reduce using rule 76 (cond -> cond_if_else_if .)
    R_BRACE         reduce using rule 76 (cond -> cond_if_else_if .)


state 26

    (77) cond -> cond_if_else .
    RETURN          reduce using rule 77 (cond -> cond_if_else .)
    ID              reduce using rule 77 (cond -> cond_if_else .)
    WRITE_FILE      reduce using rule 77 (cond -> cond_if_else .)
    PRINT           reduce using rule 77 (cond -> cond_if_else .)
    LET             reduce using rule 77 (cond -> cond_if_else .)
    FOR             reduce using rule 77 (cond -> cond_if_else .)
    WHILE           reduce using rule 77 (cond -> cond_if_else .)
    IF              reduce using rule 77 (cond -> cond_if_else .)
    $end            reduce using rule 77 (cond -> cond_if_else .)
    R_BRACE         reduce using rule 77 (cond -> cond_if_else .)


state 27

    (78) cond -> cond_if .
    RETURN          reduce using rule 78 (cond -> cond_if .)
    ID              reduce using rule 78 (cond -> cond_if .)
    WRITE_FILE      reduce using rule 78 (cond -> cond_if .)
    PRINT           reduce using rule 78 (cond -> cond_if .)
    LET             reduce using rule 78 (cond -> cond_if .)
    FOR             reduce using rule 78 (cond -> cond_if .)
    WHILE           reduce using rule 78 (cond -> cond_if .)
    IF              reduce using rule 78 (cond -> cond_if .)
    $end            reduce using rule 78 (cond -> cond_if .)
    R_BRACE         reduce using rule 78 (cond -> cond_if .)


state 28

    (75) for_loop -> FOR . L_PAREN var SEMICOLON expr SEMICOLON assign R_PAREN block
    L_PAREN         shift and go to state 72


state 29

    (74) while_loop -> WHILE . L_PAREN expr R_PAREN block
    L_PAREN         shift and go to state 73


state 30

    (86) cond_if_else_if -> simple_if . simple_else_if simple_else
    (87) cond_if_else_if -> simple_if . simple_else_if
    (85) cond_if_else -> simple_if . simple_else
    (84) cond_if -> simple_if .
    (81) simple_else_if -> . ELSE_IF L_PAREN expr R_PAREN block complex_else_if
    (80) simple_else -> . ELSE block
    RETURN          reduce using rule 84 (cond_if -> simple_if .)
    ID              reduce using rule 84 (cond_if -> simple_if .)
    WRITE_FILE      reduce using rule 84 (cond_if -> simple_if .)
    PRINT           reduce using rule 84 (cond_if -> simple_if .)
    LET             reduce using rule 84 (cond_if -> simple_if .)
    FOR             reduce using rule 84 (cond_if -> simple_if .)
    WHILE           reduce using rule 84 (cond_if -> simple_if .)
    IF              reduce using rule 84 (cond_if -> simple_if .)
    $end            reduce using rule 84 (cond_if -> simple_if .)
    R_BRACE         reduce using rule 84 (cond_if -> simple_if .)
    ELSE_IF         shift and go to state 76
    ELSE            shift and go to state 77

    simple_else_if                 shift and go to state 74
    simple_else                    shift and go to state 75

state 31

    (79) simple_if -> IF . L_PAREN expr R_PAREN block
    L_PAREN         shift and go to state 78


state 32

    (111) ignored_newlines -> NEWLINE ignored_newlines .
    RETURN          reduce using rule 111 (ignored_newlines -> NEWLINE ignored_newlines .)
    ID              reduce using rule 111 (ignored_newlines -> NEWLINE ignored_newlines .)
    WRITE_FILE      reduce using rule 111 (ignored_newlines -> NEWLINE ignored_newlines .)
    PRINT           reduce using rule 111 (ignored_newlines -> NEWLINE ignored_newlines .)
    LET             reduce using rule 111 (ignored_newlines -> NEWLINE ignored_newlines .)
    FOR             reduce using rule 111 (ignored_newlines -> NEWLINE ignored_newlines .)
    WHILE           reduce using rule 111 (ignored_newlines -> NEWLINE ignored_newlines .)
    IF              reduce using rule 111 (ignored_newlines -> NEWLINE ignored_newlines .)
    $end            reduce using rule 111 (ignored_newlines -> NEWLINE ignored_newlines .)
    R_BRACE         reduce using rule 111 (ignored_newlines -> NEWLINE ignored_newlines .)
    L_BRACE         reduce using rule 111 (ignored_newlines -> NEWLINE ignored_newlines .)
    ELSE_IF         reduce using rule 111 (ignored_newlines -> NEWLINE ignored_newlines .)
    ELSE            reduce using rule 111 (ignored_newlines -> NEWLINE ignored_newlines .)


state 33

    (97) statement -> statements eos .
    RETURN          reduce using rule 97 (statement -> statements eos .)
    ID              reduce using rule 97 (statement -> statements eos .)
    WRITE_FILE      reduce using rule 97 (statement -> statements eos .)
    PRINT           reduce using rule 97 (statement -> statements eos .)
    LET             reduce using rule 97 (statement -> statements eos .)
    FOR             reduce using rule 97 (statement -> statements eos .)
    WHILE           reduce using rule 97 (statement -> statements eos .)
    IF              reduce using rule 97 (statement -> statements eos .)
    $end            reduce using rule 97 (statement -> statements eos .)
    R_BRACE         reduce using rule 97 (statement -> statements eos .)


state 34

    (108) eos -> NEWLINE . ignored_newlines
    (110) ignored_newlines -> . empty
    (111) ignored_newlines -> . NEWLINE ignored_newlines
    (112) empty -> .
    NEWLINE         shift and go to state 4
    RETURN          reduce using rule 112 (empty -> .)
    ID              reduce using rule 112 (empty -> .)
    WRITE_FILE      reduce using rule 112 (empty -> .)
    PRINT           reduce using rule 112 (empty -> .)
    LET             reduce using rule 112 (empty -> .)
    FOR             reduce using rule 112 (empty -> .)
    WHILE           reduce using rule 112 (empty -> .)
    IF              reduce using rule 112 (empty -> .)
    $end            reduce using rule 112 (empty -> .)
    R_BRACE         reduce using rule 112 (empty -> .)

    ignored_newlines               shift and go to state 79
    empty                          shift and go to state 3

state 35

    (109) eos -> SEMICOLON . ignored_newlines
    (110) ignored_newlines -> . empty
    (111) ignored_newlines -> . NEWLINE ignored_newlines
    (112) empty -> .
    NEWLINE         shift and go to state 4
    RETURN          reduce using rule 112 (empty -> .)
    ID              reduce using rule 112 (empty -> .)
    WRITE_FILE      reduce using rule 112 (empty -> .)
    PRINT           reduce using rule 112 (empty -> .)
    LET             reduce using rule 112 (empty -> .)
    FOR             reduce using rule 112 (empty -> .)
    WHILE           reduce using rule 112 (empty -> .)
    IF              reduce using rule 112 (empty -> .)
    $end            reduce using rule 112 (empty -> .)
    R_BRACE         reduce using rule 112 (empty -> .)

    ignored_newlines               shift and go to state 80
    empty                          shift and go to state 3

state 36

    (4) globals_aux -> statement globals_aux .
    $end            reduce using rule 4 (globals_aux -> statement globals_aux .)


state 37

    (95) ret -> RETURN expr .
    NEWLINE         reduce using rule 95 (ret -> RETURN expr .)
    SEMICOLON       reduce using rule 95 (ret -> RETURN expr .)
    $end            reduce using rule 95 (ret -> RETURN expr .)


state 38

    (24) expr -> t_expr . OR expr
    (25) expr -> t_expr .
    OR              shift and go to state 81
    NEWLINE         reduce using rule 25 (expr -> t_expr .)
    SEMICOLON       reduce using rule 25 (expr -> t_expr .)
    $end            reduce using rule 25 (expr -> t_expr .)
    R_PAREN         reduce using rule 25 (expr -> t_expr .)
    COMMA           reduce using rule 25 (expr -> t_expr .)
    R_BRACKET       reduce using rule 25 (expr -> t_expr .)


state 39

    (26) t_expr -> g_expr . AND t_expr
    (27) t_expr -> g_expr .
    AND             shift and go to state 82
    OR              reduce using rule 27 (t_expr -> g_expr .)
    NEWLINE         reduce using rule 27 (t_expr -> g_expr .)
    SEMICOLON       reduce using rule 27 (t_expr -> g_expr .)
    $end            reduce using rule 27 (t_expr -> g_expr .)
    R_PAREN         reduce using rule 27 (t_expr -> g_expr .)
    COMMA           reduce using rule 27 (t_expr -> g_expr .)
    R_BRACKET       reduce using rule 27 (t_expr -> g_expr .)


state 40

    (28) g_expr -> m_expr . comparison m_expr
    (29) g_expr -> m_expr .
    (30) comparison -> . LEQT
    (31) comparison -> . GEQT
    (32) comparison -> . LT
    (33) comparison -> . GT
    (34) comparison -> . NOT_EQ
    (35) comparison -> . EQ
    AND             reduce using rule 29 (g_expr -> m_expr .)
    OR              reduce using rule 29 (g_expr -> m_expr .)
    NEWLINE         reduce using rule 29 (g_expr -> m_expr .)
    SEMICOLON       reduce using rule 29 (g_expr -> m_expr .)
    $end            reduce using rule 29 (g_expr -> m_expr .)
    R_PAREN         reduce using rule 29 (g_expr -> m_expr .)
    COMMA           reduce using rule 29 (g_expr -> m_expr .)
    R_BRACKET       reduce using rule 29 (g_expr -> m_expr .)
    LEQT            shift and go to state 84
    GEQT            shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    NOT_EQ          shift and go to state 88
    EQ              shift and go to state 89

    comparison                     shift and go to state 83

state 41

    (36) m_expr -> term . MINUS m_expr
    (37) m_expr -> term . PLUS m_expr
    (38) m_expr -> term .
    MINUS           shift and go to state 90
    PLUS            shift and go to state 91
    LEQT            reduce using rule 38 (m_expr -> term .)
    GEQT            reduce using rule 38 (m_expr -> term .)
    LT              reduce using rule 38 (m_expr -> term .)
    GT              reduce using rule 38 (m_expr -> term .)
    NOT_EQ          reduce using rule 38 (m_expr -> term .)
    EQ              reduce using rule 38 (m_expr -> term .)
    AND             reduce using rule 38 (m_expr -> term .)
    OR              reduce using rule 38 (m_expr -> term .)
    NEWLINE         reduce using rule 38 (m_expr -> term .)
    SEMICOLON       reduce using rule 38 (m_expr -> term .)
    $end            reduce using rule 38 (m_expr -> term .)
    R_PAREN         reduce using rule 38 (m_expr -> term .)
    COMMA           reduce using rule 38 (m_expr -> term .)
    R_BRACKET       reduce using rule 38 (m_expr -> term .)


state 42

    (45) factor -> MINUS . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    factor_1                       shift and go to state 92
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 43

    (46) factor -> PLUS . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    factor_1                       shift and go to state 93
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 44

    (39) term -> exp_factor . MOD term
    (40) term -> exp_factor . DIV term
    (41) term -> exp_factor . MULT term
    (42) term -> exp_factor .
    MOD             shift and go to state 94
    DIV             shift and go to state 95
    MULT            shift and go to state 96
    MINUS           reduce using rule 42 (term -> exp_factor .)
    PLUS            reduce using rule 42 (term -> exp_factor .)
    LEQT            reduce using rule 42 (term -> exp_factor .)
    GEQT            reduce using rule 42 (term -> exp_factor .)
    LT              reduce using rule 42 (term -> exp_factor .)
    GT              reduce using rule 42 (term -> exp_factor .)
    NOT_EQ          reduce using rule 42 (term -> exp_factor .)
    EQ              reduce using rule 42 (term -> exp_factor .)
    AND             reduce using rule 42 (term -> exp_factor .)
    OR              reduce using rule 42 (term -> exp_factor .)
    NEWLINE         reduce using rule 42 (term -> exp_factor .)
    SEMICOLON       reduce using rule 42 (term -> exp_factor .)
    $end            reduce using rule 42 (term -> exp_factor .)
    R_PAREN         reduce using rule 42 (term -> exp_factor .)
    COMMA           reduce using rule 42 (term -> exp_factor .)
    R_BRACKET       reduce using rule 42 (term -> exp_factor .)


state 45

    (43) exp_factor -> factor . EXP exp_factor
    (44) exp_factor -> factor .
    EXP             shift and go to state 97
    MOD             reduce using rule 44 (exp_factor -> factor .)
    DIV             reduce using rule 44 (exp_factor -> factor .)
    MULT            reduce using rule 44 (exp_factor -> factor .)
    MINUS           reduce using rule 44 (exp_factor -> factor .)
    PLUS            reduce using rule 44 (exp_factor -> factor .)
    LEQT            reduce using rule 44 (exp_factor -> factor .)
    GEQT            reduce using rule 44 (exp_factor -> factor .)
    LT              reduce using rule 44 (exp_factor -> factor .)
    GT              reduce using rule 44 (exp_factor -> factor .)
    NOT_EQ          reduce using rule 44 (exp_factor -> factor .)
    EQ              reduce using rule 44 (exp_factor -> factor .)
    AND             reduce using rule 44 (exp_factor -> factor .)
    OR              reduce using rule 44 (exp_factor -> factor .)
    NEWLINE         reduce using rule 44 (exp_factor -> factor .)
    SEMICOLON       reduce using rule 44 (exp_factor -> factor .)
    $end            reduce using rule 44 (exp_factor -> factor .)
    R_PAREN         reduce using rule 44 (exp_factor -> factor .)
    COMMA           reduce using rule 44 (exp_factor -> factor .)
    R_BRACKET       reduce using rule 44 (exp_factor -> factor .)


state 46

    (48) factor -> factor_1 .
    EXP             reduce using rule 48 (factor -> factor_1 .)
    MOD             reduce using rule 48 (factor -> factor_1 .)
    DIV             reduce using rule 48 (factor -> factor_1 .)
    MULT            reduce using rule 48 (factor -> factor_1 .)
    MINUS           reduce using rule 48 (factor -> factor_1 .)
    PLUS            reduce using rule 48 (factor -> factor_1 .)
    LEQT            reduce using rule 48 (factor -> factor_1 .)
    GEQT            reduce using rule 48 (factor -> factor_1 .)
    LT              reduce using rule 48 (factor -> factor_1 .)
    GT              reduce using rule 48 (factor -> factor_1 .)
    NOT_EQ          reduce using rule 48 (factor -> factor_1 .)
    EQ              reduce using rule 48 (factor -> factor_1 .)
    AND             reduce using rule 48 (factor -> factor_1 .)
    OR              reduce using rule 48 (factor -> factor_1 .)
    NEWLINE         reduce using rule 48 (factor -> factor_1 .)
    SEMICOLON       reduce using rule 48 (factor -> factor_1 .)
    $end            reduce using rule 48 (factor -> factor_1 .)
    R_PAREN         reduce using rule 48 (factor -> factor_1 .)
    COMMA           reduce using rule 48 (factor -> factor_1 .)
    R_BRACKET       reduce using rule 48 (factor -> factor_1 .)


state 47

    (47) factor -> NOT . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    factor_1                       shift and go to state 98
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 48

    (49) factor_1 -> ID .
    (13) tens_id -> ID . L_BRACKET expr R_BRACKET
    (61) func_call -> ID . L_PAREN func_call_1
    EXP             reduce using rule 49 (factor_1 -> ID .)
    MOD             reduce using rule 49 (factor_1 -> ID .)
    DIV             reduce using rule 49 (factor_1 -> ID .)
    MULT            reduce using rule 49 (factor_1 -> ID .)
    MINUS           reduce using rule 49 (factor_1 -> ID .)
    PLUS            reduce using rule 49 (factor_1 -> ID .)
    LEQT            reduce using rule 49 (factor_1 -> ID .)
    GEQT            reduce using rule 49 (factor_1 -> ID .)
    LT              reduce using rule 49 (factor_1 -> ID .)
    GT              reduce using rule 49 (factor_1 -> ID .)
    NOT_EQ          reduce using rule 49 (factor_1 -> ID .)
    EQ              reduce using rule 49 (factor_1 -> ID .)
    AND             reduce using rule 49 (factor_1 -> ID .)
    OR              reduce using rule 49 (factor_1 -> ID .)
    NEWLINE         reduce using rule 49 (factor_1 -> ID .)
    SEMICOLON       reduce using rule 49 (factor_1 -> ID .)
    $end            reduce using rule 49 (factor_1 -> ID .)
    R_PAREN         reduce using rule 49 (factor_1 -> ID .)
    COMMA           reduce using rule 49 (factor_1 -> ID .)
    R_BRACKET       reduce using rule 49 (factor_1 -> ID .)
    L_BRACKET       shift and go to state 99
    L_PAREN         shift and go to state 63


state 49

    (50) factor_1 -> read_file .
    EXP             reduce using rule 50 (factor_1 -> read_file .)
    MOD             reduce using rule 50 (factor_1 -> read_file .)
    DIV             reduce using rule 50 (factor_1 -> read_file .)
    MULT            reduce using rule 50 (factor_1 -> read_file .)
    MINUS           reduce using rule 50 (factor_1 -> read_file .)
    PLUS            reduce using rule 50 (factor_1 -> read_file .)
    LEQT            reduce using rule 50 (factor_1 -> read_file .)
    GEQT            reduce using rule 50 (factor_1 -> read_file .)
    LT              reduce using rule 50 (factor_1 -> read_file .)
    GT              reduce using rule 50 (factor_1 -> read_file .)
    NOT_EQ          reduce using rule 50 (factor_1 -> read_file .)
    EQ              reduce using rule 50 (factor_1 -> read_file .)
    AND             reduce using rule 50 (factor_1 -> read_file .)
    OR              reduce using rule 50 (factor_1 -> read_file .)
    NEWLINE         reduce using rule 50 (factor_1 -> read_file .)
    SEMICOLON       reduce using rule 50 (factor_1 -> read_file .)
    $end            reduce using rule 50 (factor_1 -> read_file .)
    R_PAREN         reduce using rule 50 (factor_1 -> read_file .)
    COMMA           reduce using rule 50 (factor_1 -> read_file .)
    R_BRACKET       reduce using rule 50 (factor_1 -> read_file .)


state 50

    (51) factor_1 -> read_line .
    EXP             reduce using rule 51 (factor_1 -> read_line .)
    MOD             reduce using rule 51 (factor_1 -> read_line .)
    DIV             reduce using rule 51 (factor_1 -> read_line .)
    MULT            reduce using rule 51 (factor_1 -> read_line .)
    MINUS           reduce using rule 51 (factor_1 -> read_line .)
    PLUS            reduce using rule 51 (factor_1 -> read_line .)
    LEQT            reduce using rule 51 (factor_1 -> read_line .)
    GEQT            reduce using rule 51 (factor_1 -> read_line .)
    LT              reduce using rule 51 (factor_1 -> read_line .)
    GT              reduce using rule 51 (factor_1 -> read_line .)
    NOT_EQ          reduce using rule 51 (factor_1 -> read_line .)
    EQ              reduce using rule 51 (factor_1 -> read_line .)
    AND             reduce using rule 51 (factor_1 -> read_line .)
    OR              reduce using rule 51 (factor_1 -> read_line .)
    NEWLINE         reduce using rule 51 (factor_1 -> read_line .)
    SEMICOLON       reduce using rule 51 (factor_1 -> read_line .)
    $end            reduce using rule 51 (factor_1 -> read_line .)
    R_PAREN         reduce using rule 51 (factor_1 -> read_line .)
    COMMA           reduce using rule 51 (factor_1 -> read_line .)
    R_BRACKET       reduce using rule 51 (factor_1 -> read_line .)


state 51

    (52) factor_1 -> tens_id .
    (12) tens_id -> tens_id . L_BRACKET expr R_BRACKET
    EXP             reduce using rule 52 (factor_1 -> tens_id .)
    MOD             reduce using rule 52 (factor_1 -> tens_id .)
    DIV             reduce using rule 52 (factor_1 -> tens_id .)
    MULT            reduce using rule 52 (factor_1 -> tens_id .)
    MINUS           reduce using rule 52 (factor_1 -> tens_id .)
    PLUS            reduce using rule 52 (factor_1 -> tens_id .)
    LEQT            reduce using rule 52 (factor_1 -> tens_id .)
    GEQT            reduce using rule 52 (factor_1 -> tens_id .)
    LT              reduce using rule 52 (factor_1 -> tens_id .)
    GT              reduce using rule 52 (factor_1 -> tens_id .)
    NOT_EQ          reduce using rule 52 (factor_1 -> tens_id .)
    EQ              reduce using rule 52 (factor_1 -> tens_id .)
    AND             reduce using rule 52 (factor_1 -> tens_id .)
    OR              reduce using rule 52 (factor_1 -> tens_id .)
    NEWLINE         reduce using rule 52 (factor_1 -> tens_id .)
    SEMICOLON       reduce using rule 52 (factor_1 -> tens_id .)
    $end            reduce using rule 52 (factor_1 -> tens_id .)
    R_PAREN         reduce using rule 52 (factor_1 -> tens_id .)
    COMMA           reduce using rule 52 (factor_1 -> tens_id .)
    R_BRACKET       reduce using rule 52 (factor_1 -> tens_id .)
    L_BRACKET       shift and go to state 100


state 52

    (53) factor_1 -> tens .
    EXP             reduce using rule 53 (factor_1 -> tens .)
    MOD             reduce using rule 53 (factor_1 -> tens .)
    DIV             reduce using rule 53 (factor_1 -> tens .)
    MULT            reduce using rule 53 (factor_1 -> tens .)
    MINUS           reduce using rule 53 (factor_1 -> tens .)
    PLUS            reduce using rule 53 (factor_1 -> tens .)
    LEQT            reduce using rule 53 (factor_1 -> tens .)
    GEQT            reduce using rule 53 (factor_1 -> tens .)
    LT              reduce using rule 53 (factor_1 -> tens .)
    GT              reduce using rule 53 (factor_1 -> tens .)
    NOT_EQ          reduce using rule 53 (factor_1 -> tens .)
    EQ              reduce using rule 53 (factor_1 -> tens .)
    AND             reduce using rule 53 (factor_1 -> tens .)
    OR              reduce using rule 53 (factor_1 -> tens .)
    NEWLINE         reduce using rule 53 (factor_1 -> tens .)
    SEMICOLON       reduce using rule 53 (factor_1 -> tens .)
    $end            reduce using rule 53 (factor_1 -> tens .)
    R_PAREN         reduce using rule 53 (factor_1 -> tens .)
    COMMA           reduce using rule 53 (factor_1 -> tens .)
    R_BRACKET       reduce using rule 53 (factor_1 -> tens .)


state 53

    (54) factor_1 -> func_call .
    EXP             reduce using rule 54 (factor_1 -> func_call .)
    MOD             reduce using rule 54 (factor_1 -> func_call .)
    DIV             reduce using rule 54 (factor_1 -> func_call .)
    MULT            reduce using rule 54 (factor_1 -> func_call .)
    MINUS           reduce using rule 54 (factor_1 -> func_call .)
    PLUS            reduce using rule 54 (factor_1 -> func_call .)
    LEQT            reduce using rule 54 (factor_1 -> func_call .)
    GEQT            reduce using rule 54 (factor_1 -> func_call .)
    LT              reduce using rule 54 (factor_1 -> func_call .)
    GT              reduce using rule 54 (factor_1 -> func_call .)
    NOT_EQ          reduce using rule 54 (factor_1 -> func_call .)
    EQ              reduce using rule 54 (factor_1 -> func_call .)
    AND             reduce using rule 54 (factor_1 -> func_call .)
    OR              reduce using rule 54 (factor_1 -> func_call .)
    NEWLINE         reduce using rule 54 (factor_1 -> func_call .)
    SEMICOLON       reduce using rule 54 (factor_1 -> func_call .)
    $end            reduce using rule 54 (factor_1 -> func_call .)
    R_PAREN         reduce using rule 54 (factor_1 -> func_call .)
    COMMA           reduce using rule 54 (factor_1 -> func_call .)
    R_BRACKET       reduce using rule 54 (factor_1 -> func_call .)


state 54

    (55) factor_1 -> const .
    EXP             reduce using rule 55 (factor_1 -> const .)
    MOD             reduce using rule 55 (factor_1 -> const .)
    DIV             reduce using rule 55 (factor_1 -> const .)
    MULT            reduce using rule 55 (factor_1 -> const .)
    MINUS           reduce using rule 55 (factor_1 -> const .)
    PLUS            reduce using rule 55 (factor_1 -> const .)
    LEQT            reduce using rule 55 (factor_1 -> const .)
    GEQT            reduce using rule 55 (factor_1 -> const .)
    LT              reduce using rule 55 (factor_1 -> const .)
    GT              reduce using rule 55 (factor_1 -> const .)
    NOT_EQ          reduce using rule 55 (factor_1 -> const .)
    EQ              reduce using rule 55 (factor_1 -> const .)
    AND             reduce using rule 55 (factor_1 -> const .)
    OR              reduce using rule 55 (factor_1 -> const .)
    NEWLINE         reduce using rule 55 (factor_1 -> const .)
    SEMICOLON       reduce using rule 55 (factor_1 -> const .)
    $end            reduce using rule 55 (factor_1 -> const .)
    R_PAREN         reduce using rule 55 (factor_1 -> const .)
    COMMA           reduce using rule 55 (factor_1 -> const .)
    R_BRACKET       reduce using rule 55 (factor_1 -> const .)


state 55

    (56) factor_1 -> L_PAREN . expr R_PAREN
    (24) expr -> . t_expr OR expr
    (25) expr -> . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    expr                           shift and go to state 101
    t_expr                         shift and go to state 38
    g_expr                         shift and go to state 39
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 56

    (59) read_file -> READ_FILE . L_PAREN expr R_PAREN
    L_PAREN         shift and go to state 102


state 57

    (57) read_line -> READ_LINE . L_PAREN R_PAREN
    L_PAREN         shift and go to state 103


state 58

    (9) tens -> L_BRACKET . expr tens_1
    (24) expr -> . t_expr OR expr
    (25) expr -> . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    expr                           shift and go to state 104
    t_expr                         shift and go to state 38
    g_expr                         shift and go to state 39
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 59

    (5) const -> STRING_V .
    EXP             reduce using rule 5 (const -> STRING_V .)
    MOD             reduce using rule 5 (const -> STRING_V .)
    DIV             reduce using rule 5 (const -> STRING_V .)
    MULT            reduce using rule 5 (const -> STRING_V .)
    MINUS           reduce using rule 5 (const -> STRING_V .)
    PLUS            reduce using rule 5 (const -> STRING_V .)
    LEQT            reduce using rule 5 (const -> STRING_V .)
    GEQT            reduce using rule 5 (const -> STRING_V .)
    LT              reduce using rule 5 (const -> STRING_V .)
    GT              reduce using rule 5 (const -> STRING_V .)
    NOT_EQ          reduce using rule 5 (const -> STRING_V .)
    EQ              reduce using rule 5 (const -> STRING_V .)
    AND             reduce using rule 5 (const -> STRING_V .)
    OR              reduce using rule 5 (const -> STRING_V .)
    NEWLINE         reduce using rule 5 (const -> STRING_V .)
    SEMICOLON       reduce using rule 5 (const -> STRING_V .)
    $end            reduce using rule 5 (const -> STRING_V .)
    R_PAREN         reduce using rule 5 (const -> STRING_V .)
    COMMA           reduce using rule 5 (const -> STRING_V .)
    R_BRACKET       reduce using rule 5 (const -> STRING_V .)


state 60

    (6) const -> BOOL_V .
    EXP             reduce using rule 6 (const -> BOOL_V .)
    MOD             reduce using rule 6 (const -> BOOL_V .)
    DIV             reduce using rule 6 (const -> BOOL_V .)
    MULT            reduce using rule 6 (const -> BOOL_V .)
    MINUS           reduce using rule 6 (const -> BOOL_V .)
    PLUS            reduce using rule 6 (const -> BOOL_V .)
    LEQT            reduce using rule 6 (const -> BOOL_V .)
    GEQT            reduce using rule 6 (const -> BOOL_V .)
    LT              reduce using rule 6 (const -> BOOL_V .)
    GT              reduce using rule 6 (const -> BOOL_V .)
    NOT_EQ          reduce using rule 6 (const -> BOOL_V .)
    EQ              reduce using rule 6 (const -> BOOL_V .)
    AND             reduce using rule 6 (const -> BOOL_V .)
    OR              reduce using rule 6 (const -> BOOL_V .)
    NEWLINE         reduce using rule 6 (const -> BOOL_V .)
    SEMICOLON       reduce using rule 6 (const -> BOOL_V .)
    $end            reduce using rule 6 (const -> BOOL_V .)
    R_PAREN         reduce using rule 6 (const -> BOOL_V .)
    COMMA           reduce using rule 6 (const -> BOOL_V .)
    R_BRACKET       reduce using rule 6 (const -> BOOL_V .)


state 61

    (7) const -> FLOAT_V .
    EXP             reduce using rule 7 (const -> FLOAT_V .)
    MOD             reduce using rule 7 (const -> FLOAT_V .)
    DIV             reduce using rule 7 (const -> FLOAT_V .)
    MULT            reduce using rule 7 (const -> FLOAT_V .)
    MINUS           reduce using rule 7 (const -> FLOAT_V .)
    PLUS            reduce using rule 7 (const -> FLOAT_V .)
    LEQT            reduce using rule 7 (const -> FLOAT_V .)
    GEQT            reduce using rule 7 (const -> FLOAT_V .)
    LT              reduce using rule 7 (const -> FLOAT_V .)
    GT              reduce using rule 7 (const -> FLOAT_V .)
    NOT_EQ          reduce using rule 7 (const -> FLOAT_V .)
    EQ              reduce using rule 7 (const -> FLOAT_V .)
    AND             reduce using rule 7 (const -> FLOAT_V .)
    OR              reduce using rule 7 (const -> FLOAT_V .)
    NEWLINE         reduce using rule 7 (const -> FLOAT_V .)
    SEMICOLON       reduce using rule 7 (const -> FLOAT_V .)
    $end            reduce using rule 7 (const -> FLOAT_V .)
    R_PAREN         reduce using rule 7 (const -> FLOAT_V .)
    COMMA           reduce using rule 7 (const -> FLOAT_V .)
    R_BRACKET       reduce using rule 7 (const -> FLOAT_V .)


state 62

    (8) const -> INT_V .
    EXP             reduce using rule 8 (const -> INT_V .)
    MOD             reduce using rule 8 (const -> INT_V .)
    DIV             reduce using rule 8 (const -> INT_V .)
    MULT            reduce using rule 8 (const -> INT_V .)
    MINUS           reduce using rule 8 (const -> INT_V .)
    PLUS            reduce using rule 8 (const -> INT_V .)
    LEQT            reduce using rule 8 (const -> INT_V .)
    GEQT            reduce using rule 8 (const -> INT_V .)
    LT              reduce using rule 8 (const -> INT_V .)
    GT              reduce using rule 8 (const -> INT_V .)
    NOT_EQ          reduce using rule 8 (const -> INT_V .)
    EQ              reduce using rule 8 (const -> INT_V .)
    AND             reduce using rule 8 (const -> INT_V .)
    OR              reduce using rule 8 (const -> INT_V .)
    NEWLINE         reduce using rule 8 (const -> INT_V .)
    SEMICOLON       reduce using rule 8 (const -> INT_V .)
    $end            reduce using rule 8 (const -> INT_V .)
    R_PAREN         reduce using rule 8 (const -> INT_V .)
    COMMA           reduce using rule 8 (const -> INT_V .)
    R_BRACKET       reduce using rule 8 (const -> INT_V .)


state 63

    (61) func_call -> ID L_PAREN . func_call_1
    (62) func_call_1 -> . expr COMMA func_call_1
    (63) func_call_1 -> . expr R_PAREN
    (64) func_call_1 -> . R_PAREN
    (24) expr -> . t_expr OR expr
    (25) expr -> . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    R_PAREN         shift and go to state 107
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    func_call_1                    shift and go to state 105
    expr                           shift and go to state 106
    t_expr                         shift and go to state 38
    g_expr                         shift and go to state 39
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 64

    (65) assign -> ID ASSIG . expr
    (24) expr -> . t_expr OR expr
    (25) expr -> . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    expr                           shift and go to state 108
    t_expr                         shift and go to state 38
    g_expr                         shift and go to state 39
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 65

    (60) write_file -> WRITE_FILE L_PAREN . func_call_1
    (62) func_call_1 -> . expr COMMA func_call_1
    (63) func_call_1 -> . expr R_PAREN
    (64) func_call_1 -> . R_PAREN
    (24) expr -> . t_expr OR expr
    (25) expr -> . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    R_PAREN         shift and go to state 107
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    func_call_1                    shift and go to state 109
    expr                           shift and go to state 106
    t_expr                         shift and go to state 38
    g_expr                         shift and go to state 39
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 66

    (58) print_rule -> PRINT L_PAREN . func_call_1
    (62) func_call_1 -> . expr COMMA func_call_1
    (63) func_call_1 -> . expr R_PAREN
    (64) func_call_1 -> . R_PAREN
    (24) expr -> . t_expr OR expr
    (25) expr -> . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    R_PAREN         shift and go to state 107
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    func_call_1                    shift and go to state 110
    expr                           shift and go to state 106
    t_expr                         shift and go to state 38
    g_expr                         shift and go to state 39
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 67

    (66) var -> LET var_1 .
    NEWLINE         reduce using rule 66 (var -> LET var_1 .)
    SEMICOLON       reduce using rule 66 (var -> LET var_1 .)
    $end            reduce using rule 66 (var -> LET var_1 .)


state 68

    (88) func -> LET ID . L_PAREN func_params R_PAREN COLON func_type block
    (73) var_id -> ID .
    L_PAREN         shift and go to state 111
    COLON           reduce using rule 73 (var_id -> ID .)
    L_BRACKET       reduce using rule 73 (var_id -> ID .)


state 69

    (67) var_1 -> var_2 . COMMA var_1
    (68) var_1 -> var_2 .
    COMMA           shift and go to state 112
    NEWLINE         reduce using rule 68 (var_1 -> var_2 .)
    SEMICOLON       reduce using rule 68 (var_1 -> var_2 .)
    $end            reduce using rule 68 (var_1 -> var_2 .)


state 70

    (69) var_2 -> var_3 . ASSIG expr
    (70) var_2 -> var_3 .
    ASSIG           shift and go to state 113
    COMMA           reduce using rule 70 (var_2 -> var_3 .)
    NEWLINE         reduce using rule 70 (var_2 -> var_3 .)
    SEMICOLON       reduce using rule 70 (var_2 -> var_3 .)
    $end            reduce using rule 70 (var_2 -> var_3 .)


state 71

    (71) var_3 -> var_id . COLON const_type
    (72) var_id -> var_id . L_BRACKET INT_V R_BRACKET
    COLON           shift and go to state 114
    L_BRACKET       shift and go to state 115


state 72

    (75) for_loop -> FOR L_PAREN . var SEMICOLON expr SEMICOLON assign R_PAREN block
    (66) var -> . LET var_1
    LET             shift and go to state 117

    var                            shift and go to state 116

state 73

    (74) while_loop -> WHILE L_PAREN . expr R_PAREN block
    (24) expr -> . t_expr OR expr
    (25) expr -> . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    expr                           shift and go to state 118
    t_expr                         shift and go to state 38
    g_expr                         shift and go to state 39
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 74

    (86) cond_if_else_if -> simple_if simple_else_if . simple_else
    (87) cond_if_else_if -> simple_if simple_else_if .
    (80) simple_else -> . ELSE block
    RETURN          reduce using rule 87 (cond_if_else_if -> simple_if simple_else_if .)
    ID              reduce using rule 87 (cond_if_else_if -> simple_if simple_else_if .)
    WRITE_FILE      reduce using rule 87 (cond_if_else_if -> simple_if simple_else_if .)
    PRINT           reduce using rule 87 (cond_if_else_if -> simple_if simple_else_if .)
    LET             reduce using rule 87 (cond_if_else_if -> simple_if simple_else_if .)
    FOR             reduce using rule 87 (cond_if_else_if -> simple_if simple_else_if .)
    WHILE           reduce using rule 87 (cond_if_else_if -> simple_if simple_else_if .)
    IF              reduce using rule 87 (cond_if_else_if -> simple_if simple_else_if .)
    $end            reduce using rule 87 (cond_if_else_if -> simple_if simple_else_if .)
    R_BRACE         reduce using rule 87 (cond_if_else_if -> simple_if simple_else_if .)
    ELSE            shift and go to state 77

    simple_else                    shift and go to state 119

state 75

    (85) cond_if_else -> simple_if simple_else .
    RETURN          reduce using rule 85 (cond_if_else -> simple_if simple_else .)
    ID              reduce using rule 85 (cond_if_else -> simple_if simple_else .)
    WRITE_FILE      reduce using rule 85 (cond_if_else -> simple_if simple_else .)
    PRINT           reduce using rule 85 (cond_if_else -> simple_if simple_else .)
    LET             reduce using rule 85 (cond_if_else -> simple_if simple_else .)
    FOR             reduce using rule 85 (cond_if_else -> simple_if simple_else .)
    WHILE           reduce using rule 85 (cond_if_else -> simple_if simple_else .)
    IF              reduce using rule 85 (cond_if_else -> simple_if simple_else .)
    $end            reduce using rule 85 (cond_if_else -> simple_if simple_else .)
    R_BRACE         reduce using rule 85 (cond_if_else -> simple_if simple_else .)


state 76

    (81) simple_else_if -> ELSE_IF . L_PAREN expr R_PAREN block complex_else_if
    L_PAREN         shift and go to state 120


state 77

    (80) simple_else -> ELSE . block
    (14) block -> . ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines
    (110) ignored_newlines -> . empty
    (111) ignored_newlines -> . NEWLINE ignored_newlines
    (112) empty -> .
    NEWLINE         shift and go to state 4
    L_BRACE         reduce using rule 112 (empty -> .)

    block                          shift and go to state 121
    ignored_newlines               shift and go to state 122
    empty                          shift and go to state 3

state 78

    (79) simple_if -> IF L_PAREN . expr R_PAREN block
    (24) expr -> . t_expr OR expr
    (25) expr -> . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    expr                           shift and go to state 123
    t_expr                         shift and go to state 38
    g_expr                         shift and go to state 39
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 79

    (108) eos -> NEWLINE ignored_newlines .
    RETURN          reduce using rule 108 (eos -> NEWLINE ignored_newlines .)
    ID              reduce using rule 108 (eos -> NEWLINE ignored_newlines .)
    WRITE_FILE      reduce using rule 108 (eos -> NEWLINE ignored_newlines .)
    PRINT           reduce using rule 108 (eos -> NEWLINE ignored_newlines .)
    LET             reduce using rule 108 (eos -> NEWLINE ignored_newlines .)
    FOR             reduce using rule 108 (eos -> NEWLINE ignored_newlines .)
    WHILE           reduce using rule 108 (eos -> NEWLINE ignored_newlines .)
    IF              reduce using rule 108 (eos -> NEWLINE ignored_newlines .)
    $end            reduce using rule 108 (eos -> NEWLINE ignored_newlines .)
    R_BRACE         reduce using rule 108 (eos -> NEWLINE ignored_newlines .)


state 80

    (109) eos -> SEMICOLON ignored_newlines .
    RETURN          reduce using rule 109 (eos -> SEMICOLON ignored_newlines .)
    ID              reduce using rule 109 (eos -> SEMICOLON ignored_newlines .)
    WRITE_FILE      reduce using rule 109 (eos -> SEMICOLON ignored_newlines .)
    PRINT           reduce using rule 109 (eos -> SEMICOLON ignored_newlines .)
    LET             reduce using rule 109 (eos -> SEMICOLON ignored_newlines .)
    FOR             reduce using rule 109 (eos -> SEMICOLON ignored_newlines .)
    WHILE           reduce using rule 109 (eos -> SEMICOLON ignored_newlines .)
    IF              reduce using rule 109 (eos -> SEMICOLON ignored_newlines .)
    $end            reduce using rule 109 (eos -> SEMICOLON ignored_newlines .)
    R_BRACE         reduce using rule 109 (eos -> SEMICOLON ignored_newlines .)


state 81

    (24) expr -> t_expr OR . expr
    (24) expr -> . t_expr OR expr
    (25) expr -> . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    t_expr                         shift and go to state 38
    expr                           shift and go to state 124
    g_expr                         shift and go to state 39
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 82

    (26) t_expr -> g_expr AND . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    g_expr                         shift and go to state 39
    t_expr                         shift and go to state 125
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 83

    (28) g_expr -> m_expr comparison . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    m_expr                         shift and go to state 126
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 84

    (30) comparison -> LEQT .
    MINUS           reduce using rule 30 (comparison -> LEQT .)
    PLUS            reduce using rule 30 (comparison -> LEQT .)
    NOT             reduce using rule 30 (comparison -> LEQT .)
    ID              reduce using rule 30 (comparison -> LEQT .)
    L_PAREN         reduce using rule 30 (comparison -> LEQT .)
    READ_FILE       reduce using rule 30 (comparison -> LEQT .)
    READ_LINE       reduce using rule 30 (comparison -> LEQT .)
    L_BRACKET       reduce using rule 30 (comparison -> LEQT .)
    STRING_V        reduce using rule 30 (comparison -> LEQT .)
    BOOL_V          reduce using rule 30 (comparison -> LEQT .)
    FLOAT_V         reduce using rule 30 (comparison -> LEQT .)
    INT_V           reduce using rule 30 (comparison -> LEQT .)


state 85

    (31) comparison -> GEQT .
    MINUS           reduce using rule 31 (comparison -> GEQT .)
    PLUS            reduce using rule 31 (comparison -> GEQT .)
    NOT             reduce using rule 31 (comparison -> GEQT .)
    ID              reduce using rule 31 (comparison -> GEQT .)
    L_PAREN         reduce using rule 31 (comparison -> GEQT .)
    READ_FILE       reduce using rule 31 (comparison -> GEQT .)
    READ_LINE       reduce using rule 31 (comparison -> GEQT .)
    L_BRACKET       reduce using rule 31 (comparison -> GEQT .)
    STRING_V        reduce using rule 31 (comparison -> GEQT .)
    BOOL_V          reduce using rule 31 (comparison -> GEQT .)
    FLOAT_V         reduce using rule 31 (comparison -> GEQT .)
    INT_V           reduce using rule 31 (comparison -> GEQT .)


state 86

    (32) comparison -> LT .
    MINUS           reduce using rule 32 (comparison -> LT .)
    PLUS            reduce using rule 32 (comparison -> LT .)
    NOT             reduce using rule 32 (comparison -> LT .)
    ID              reduce using rule 32 (comparison -> LT .)
    L_PAREN         reduce using rule 32 (comparison -> LT .)
    READ_FILE       reduce using rule 32 (comparison -> LT .)
    READ_LINE       reduce using rule 32 (comparison -> LT .)
    L_BRACKET       reduce using rule 32 (comparison -> LT .)
    STRING_V        reduce using rule 32 (comparison -> LT .)
    BOOL_V          reduce using rule 32 (comparison -> LT .)
    FLOAT_V         reduce using rule 32 (comparison -> LT .)
    INT_V           reduce using rule 32 (comparison -> LT .)


state 87

    (33) comparison -> GT .
    MINUS           reduce using rule 33 (comparison -> GT .)
    PLUS            reduce using rule 33 (comparison -> GT .)
    NOT             reduce using rule 33 (comparison -> GT .)
    ID              reduce using rule 33 (comparison -> GT .)
    L_PAREN         reduce using rule 33 (comparison -> GT .)
    READ_FILE       reduce using rule 33 (comparison -> GT .)
    READ_LINE       reduce using rule 33 (comparison -> GT .)
    L_BRACKET       reduce using rule 33 (comparison -> GT .)
    STRING_V        reduce using rule 33 (comparison -> GT .)
    BOOL_V          reduce using rule 33 (comparison -> GT .)
    FLOAT_V         reduce using rule 33 (comparison -> GT .)
    INT_V           reduce using rule 33 (comparison -> GT .)


state 88

    (34) comparison -> NOT_EQ .
    MINUS           reduce using rule 34 (comparison -> NOT_EQ .)
    PLUS            reduce using rule 34 (comparison -> NOT_EQ .)
    NOT             reduce using rule 34 (comparison -> NOT_EQ .)
    ID              reduce using rule 34 (comparison -> NOT_EQ .)
    L_PAREN         reduce using rule 34 (comparison -> NOT_EQ .)
    READ_FILE       reduce using rule 34 (comparison -> NOT_EQ .)
    READ_LINE       reduce using rule 34 (comparison -> NOT_EQ .)
    L_BRACKET       reduce using rule 34 (comparison -> NOT_EQ .)
    STRING_V        reduce using rule 34 (comparison -> NOT_EQ .)
    BOOL_V          reduce using rule 34 (comparison -> NOT_EQ .)
    FLOAT_V         reduce using rule 34 (comparison -> NOT_EQ .)
    INT_V           reduce using rule 34 (comparison -> NOT_EQ .)


state 89

    (35) comparison -> EQ .
    MINUS           reduce using rule 35 (comparison -> EQ .)
    PLUS            reduce using rule 35 (comparison -> EQ .)
    NOT             reduce using rule 35 (comparison -> EQ .)
    ID              reduce using rule 35 (comparison -> EQ .)
    L_PAREN         reduce using rule 35 (comparison -> EQ .)
    READ_FILE       reduce using rule 35 (comparison -> EQ .)
    READ_LINE       reduce using rule 35 (comparison -> EQ .)
    L_BRACKET       reduce using rule 35 (comparison -> EQ .)
    STRING_V        reduce using rule 35 (comparison -> EQ .)
    BOOL_V          reduce using rule 35 (comparison -> EQ .)
    FLOAT_V         reduce using rule 35 (comparison -> EQ .)
    INT_V           reduce using rule 35 (comparison -> EQ .)


state 90

    (36) m_expr -> term MINUS . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    term                           shift and go to state 41
    m_expr                         shift and go to state 127
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 91

    (37) m_expr -> term PLUS . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    term                           shift and go to state 41
    m_expr                         shift and go to state 128
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 92

    (45) factor -> MINUS factor_1 .
    EXP             reduce using rule 45 (factor -> MINUS factor_1 .)
    MOD             reduce using rule 45 (factor -> MINUS factor_1 .)
    DIV             reduce using rule 45 (factor -> MINUS factor_1 .)
    MULT            reduce using rule 45 (factor -> MINUS factor_1 .)
    MINUS           reduce using rule 45 (factor -> MINUS factor_1 .)
    PLUS            reduce using rule 45 (factor -> MINUS factor_1 .)
    LEQT            reduce using rule 45 (factor -> MINUS factor_1 .)
    GEQT            reduce using rule 45 (factor -> MINUS factor_1 .)
    LT              reduce using rule 45 (factor -> MINUS factor_1 .)
    GT              reduce using rule 45 (factor -> MINUS factor_1 .)
    NOT_EQ          reduce using rule 45 (factor -> MINUS factor_1 .)
    EQ              reduce using rule 45 (factor -> MINUS factor_1 .)
    AND             reduce using rule 45 (factor -> MINUS factor_1 .)
    OR              reduce using rule 45 (factor -> MINUS factor_1 .)
    NEWLINE         reduce using rule 45 (factor -> MINUS factor_1 .)
    SEMICOLON       reduce using rule 45 (factor -> MINUS factor_1 .)
    $end            reduce using rule 45 (factor -> MINUS factor_1 .)
    R_PAREN         reduce using rule 45 (factor -> MINUS factor_1 .)
    COMMA           reduce using rule 45 (factor -> MINUS factor_1 .)
    R_BRACKET       reduce using rule 45 (factor -> MINUS factor_1 .)


state 93

    (46) factor -> PLUS factor_1 .
    EXP             reduce using rule 46 (factor -> PLUS factor_1 .)
    MOD             reduce using rule 46 (factor -> PLUS factor_1 .)
    DIV             reduce using rule 46 (factor -> PLUS factor_1 .)
    MULT            reduce using rule 46 (factor -> PLUS factor_1 .)
    MINUS           reduce using rule 46 (factor -> PLUS factor_1 .)
    PLUS            reduce using rule 46 (factor -> PLUS factor_1 .)
    LEQT            reduce using rule 46 (factor -> PLUS factor_1 .)
    GEQT            reduce using rule 46 (factor -> PLUS factor_1 .)
    LT              reduce using rule 46 (factor -> PLUS factor_1 .)
    GT              reduce using rule 46 (factor -> PLUS factor_1 .)
    NOT_EQ          reduce using rule 46 (factor -> PLUS factor_1 .)
    EQ              reduce using rule 46 (factor -> PLUS factor_1 .)
    AND             reduce using rule 46 (factor -> PLUS factor_1 .)
    OR              reduce using rule 46 (factor -> PLUS factor_1 .)
    NEWLINE         reduce using rule 46 (factor -> PLUS factor_1 .)
    SEMICOLON       reduce using rule 46 (factor -> PLUS factor_1 .)
    $end            reduce using rule 46 (factor -> PLUS factor_1 .)
    R_PAREN         reduce using rule 46 (factor -> PLUS factor_1 .)
    COMMA           reduce using rule 46 (factor -> PLUS factor_1 .)
    R_BRACKET       reduce using rule 46 (factor -> PLUS factor_1 .)


state 94

    (39) term -> exp_factor MOD . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    exp_factor                     shift and go to state 44
    term                           shift and go to state 129
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 95

    (40) term -> exp_factor DIV . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    exp_factor                     shift and go to state 44
    term                           shift and go to state 130
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 96

    (41) term -> exp_factor MULT . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    exp_factor                     shift and go to state 44
    term                           shift and go to state 131
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 97

    (43) exp_factor -> factor EXP . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    factor                         shift and go to state 45
    exp_factor                     shift and go to state 132
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 98

    (47) factor -> NOT factor_1 .
    EXP             reduce using rule 47 (factor -> NOT factor_1 .)
    MOD             reduce using rule 47 (factor -> NOT factor_1 .)
    DIV             reduce using rule 47 (factor -> NOT factor_1 .)
    MULT            reduce using rule 47 (factor -> NOT factor_1 .)
    MINUS           reduce using rule 47 (factor -> NOT factor_1 .)
    PLUS            reduce using rule 47 (factor -> NOT factor_1 .)
    LEQT            reduce using rule 47 (factor -> NOT factor_1 .)
    GEQT            reduce using rule 47 (factor -> NOT factor_1 .)
    LT              reduce using rule 47 (factor -> NOT factor_1 .)
    GT              reduce using rule 47 (factor -> NOT factor_1 .)
    NOT_EQ          reduce using rule 47 (factor -> NOT factor_1 .)
    EQ              reduce using rule 47 (factor -> NOT factor_1 .)
    AND             reduce using rule 47 (factor -> NOT factor_1 .)
    OR              reduce using rule 47 (factor -> NOT factor_1 .)
    NEWLINE         reduce using rule 47 (factor -> NOT factor_1 .)
    SEMICOLON       reduce using rule 47 (factor -> NOT factor_1 .)
    $end            reduce using rule 47 (factor -> NOT factor_1 .)
    R_PAREN         reduce using rule 47 (factor -> NOT factor_1 .)
    COMMA           reduce using rule 47 (factor -> NOT factor_1 .)
    R_BRACKET       reduce using rule 47 (factor -> NOT factor_1 .)


state 99

    (13) tens_id -> ID L_BRACKET . expr R_BRACKET
    (24) expr -> . t_expr OR expr
    (25) expr -> . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    expr                           shift and go to state 133
    t_expr                         shift and go to state 38
    g_expr                         shift and go to state 39
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 100

    (12) tens_id -> tens_id L_BRACKET . expr R_BRACKET
    (24) expr -> . t_expr OR expr
    (25) expr -> . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    tens_id                        shift and go to state 51
    expr                           shift and go to state 134
    t_expr                         shift and go to state 38
    g_expr                         shift and go to state 39
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 101

    (56) factor_1 -> L_PAREN expr . R_PAREN
    R_PAREN         shift and go to state 135


state 102

    (59) read_file -> READ_FILE L_PAREN . expr R_PAREN
    (24) expr -> . t_expr OR expr
    (25) expr -> . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    expr                           shift and go to state 136
    t_expr                         shift and go to state 38
    g_expr                         shift and go to state 39
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 103

    (57) read_line -> READ_LINE L_PAREN . R_PAREN
    R_PAREN         shift and go to state 137


state 104

    (9) tens -> L_BRACKET expr . tens_1
    (10) tens_1 -> . COMMA expr tens_1
    (11) tens_1 -> . R_BRACKET
    COMMA           shift and go to state 139
    R_BRACKET       shift and go to state 140

    tens_1                         shift and go to state 138

state 105

    (61) func_call -> ID L_PAREN func_call_1 .
    NEWLINE         reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    SEMICOLON       reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    $end            reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    EXP             reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    MOD             reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    DIV             reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    MULT            reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    MINUS           reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    PLUS            reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    LEQT            reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    GEQT            reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    LT              reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    GT              reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    NOT_EQ          reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    EQ              reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    AND             reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    OR              reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    R_PAREN         reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    COMMA           reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)
    R_BRACKET       reduce using rule 61 (func_call -> ID L_PAREN func_call_1 .)


state 106

    (62) func_call_1 -> expr . COMMA func_call_1
    (63) func_call_1 -> expr . R_PAREN
    COMMA           shift and go to state 141
    R_PAREN         shift and go to state 142


state 107

    (64) func_call_1 -> R_PAREN .
    NEWLINE         reduce using rule 64 (func_call_1 -> R_PAREN .)
    SEMICOLON       reduce using rule 64 (func_call_1 -> R_PAREN .)
    $end            reduce using rule 64 (func_call_1 -> R_PAREN .)
    EXP             reduce using rule 64 (func_call_1 -> R_PAREN .)
    MOD             reduce using rule 64 (func_call_1 -> R_PAREN .)
    DIV             reduce using rule 64 (func_call_1 -> R_PAREN .)
    MULT            reduce using rule 64 (func_call_1 -> R_PAREN .)
    MINUS           reduce using rule 64 (func_call_1 -> R_PAREN .)
    PLUS            reduce using rule 64 (func_call_1 -> R_PAREN .)
    LEQT            reduce using rule 64 (func_call_1 -> R_PAREN .)
    GEQT            reduce using rule 64 (func_call_1 -> R_PAREN .)
    LT              reduce using rule 64 (func_call_1 -> R_PAREN .)
    GT              reduce using rule 64 (func_call_1 -> R_PAREN .)
    NOT_EQ          reduce using rule 64 (func_call_1 -> R_PAREN .)
    EQ              reduce using rule 64 (func_call_1 -> R_PAREN .)
    AND             reduce using rule 64 (func_call_1 -> R_PAREN .)
    OR              reduce using rule 64 (func_call_1 -> R_PAREN .)
    R_PAREN         reduce using rule 64 (func_call_1 -> R_PAREN .)
    COMMA           reduce using rule 64 (func_call_1 -> R_PAREN .)
    R_BRACKET       reduce using rule 64 (func_call_1 -> R_PAREN .)


state 108

    (65) assign -> ID ASSIG expr .
    NEWLINE         reduce using rule 65 (assign -> ID ASSIG expr .)
    SEMICOLON       reduce using rule 65 (assign -> ID ASSIG expr .)
    $end            reduce using rule 65 (assign -> ID ASSIG expr .)
    R_PAREN         reduce using rule 65 (assign -> ID ASSIG expr .)


state 109

    (60) write_file -> WRITE_FILE L_PAREN func_call_1 .
    NEWLINE         reduce using rule 60 (write_file -> WRITE_FILE L_PAREN func_call_1 .)
    SEMICOLON       reduce using rule 60 (write_file -> WRITE_FILE L_PAREN func_call_1 .)
    $end            reduce using rule 60 (write_file -> WRITE_FILE L_PAREN func_call_1 .)


state 110

    (58) print_rule -> PRINT L_PAREN func_call_1 .
    NEWLINE         reduce using rule 58 (print_rule -> PRINT L_PAREN func_call_1 .)
    SEMICOLON       reduce using rule 58 (print_rule -> PRINT L_PAREN func_call_1 .)
    $end            reduce using rule 58 (print_rule -> PRINT L_PAREN func_call_1 .)


state 111

    (88) func -> LET ID L_PAREN . func_params R_PAREN COLON func_type block
    (89) func_params -> . empty
    (90) func_params -> . func_params_1
    (112) empty -> .
    (91) func_params_1 -> . ID COLON const_type COMMA func_params_1
    (92) func_params_1 -> . ID COLON const_type
    R_PAREN         reduce using rule 112 (empty -> .)
    ID              shift and go to state 143

    func_params                    shift and go to state 144
    empty                          shift and go to state 145
    func_params_1                  shift and go to state 146

state 112

    (67) var_1 -> var_2 COMMA . var_1
    (67) var_1 -> . var_2 COMMA var_1
    (68) var_1 -> . var_2
    (69) var_2 -> . var_3 ASSIG expr
    (70) var_2 -> . var_3
    (71) var_3 -> . var_id COLON const_type
    (72) var_id -> . var_id L_BRACKET INT_V R_BRACKET
    (73) var_id -> . ID
    ID              shift and go to state 148

    var_2                          shift and go to state 69
    var_1                          shift and go to state 147
    var_3                          shift and go to state 70
    var_id                         shift and go to state 71

state 113

    (69) var_2 -> var_3 ASSIG . expr
    (24) expr -> . t_expr OR expr
    (25) expr -> . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    expr                           shift and go to state 149
    t_expr                         shift and go to state 38
    g_expr                         shift and go to state 39
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 114

    (71) var_3 -> var_id COLON . const_type
    (17) const_type -> . GPU_BOOL_T
    (18) const_type -> . GPU_FLOAT_T
    (19) const_type -> . GPU_INT_T
    (20) const_type -> . BOOL_T
    (21) const_type -> . STRING_T
    (22) const_type -> . FLOAT_T
    (23) const_type -> . INT_T
    GPU_BOOL_T      shift and go to state 151
    GPU_FLOAT_T     shift and go to state 152
    GPU_INT_T       shift and go to state 153
    BOOL_T          shift and go to state 154
    STRING_T        shift and go to state 155
    FLOAT_T         shift and go to state 156
    INT_T           shift and go to state 157

    const_type                     shift and go to state 150

state 115

    (72) var_id -> var_id L_BRACKET . INT_V R_BRACKET
    INT_V           shift and go to state 158


state 116

    (75) for_loop -> FOR L_PAREN var . SEMICOLON expr SEMICOLON assign R_PAREN block
    SEMICOLON       shift and go to state 159


state 117

    (66) var -> LET . var_1
    (67) var_1 -> . var_2 COMMA var_1
    (68) var_1 -> . var_2
    (69) var_2 -> . var_3 ASSIG expr
    (70) var_2 -> . var_3
    (71) var_3 -> . var_id COLON const_type
    (72) var_id -> . var_id L_BRACKET INT_V R_BRACKET
    (73) var_id -> . ID
    ID              shift and go to state 148

    var_1                          shift and go to state 67
    var_2                          shift and go to state 69
    var_3                          shift and go to state 70
    var_id                         shift and go to state 71

state 118

    (74) while_loop -> WHILE L_PAREN expr . R_PAREN block
    R_PAREN         shift and go to state 160


state 119

    (86) cond_if_else_if -> simple_if simple_else_if simple_else .
    RETURN          reduce using rule 86 (cond_if_else_if -> simple_if simple_else_if simple_else .)
    ID              reduce using rule 86 (cond_if_else_if -> simple_if simple_else_if simple_else .)
    WRITE_FILE      reduce using rule 86 (cond_if_else_if -> simple_if simple_else_if simple_else .)
    PRINT           reduce using rule 86 (cond_if_else_if -> simple_if simple_else_if simple_else .)
    LET             reduce using rule 86 (cond_if_else_if -> simple_if simple_else_if simple_else .)
    FOR             reduce using rule 86 (cond_if_else_if -> simple_if simple_else_if simple_else .)
    WHILE           reduce using rule 86 (cond_if_else_if -> simple_if simple_else_if simple_else .)
    IF              reduce using rule 86 (cond_if_else_if -> simple_if simple_else_if simple_else .)
    $end            reduce using rule 86 (cond_if_else_if -> simple_if simple_else_if simple_else .)
    R_BRACE         reduce using rule 86 (cond_if_else_if -> simple_if simple_else_if simple_else .)


state 120

    (81) simple_else_if -> ELSE_IF L_PAREN . expr R_PAREN block complex_else_if
    (24) expr -> . t_expr OR expr
    (25) expr -> . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    expr                           shift and go to state 161
    t_expr                         shift and go to state 38
    g_expr                         shift and go to state 39
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 121

    (80) simple_else -> ELSE block .
    RETURN          reduce using rule 80 (simple_else -> ELSE block .)
    ID              reduce using rule 80 (simple_else -> ELSE block .)
    WRITE_FILE      reduce using rule 80 (simple_else -> ELSE block .)
    PRINT           reduce using rule 80 (simple_else -> ELSE block .)
    LET             reduce using rule 80 (simple_else -> ELSE block .)
    FOR             reduce using rule 80 (simple_else -> ELSE block .)
    WHILE           reduce using rule 80 (simple_else -> ELSE block .)
    IF              reduce using rule 80 (simple_else -> ELSE block .)
    $end            reduce using rule 80 (simple_else -> ELSE block .)
    R_BRACE         reduce using rule 80 (simple_else -> ELSE block .)


state 122

    (14) block -> ignored_newlines . L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines
    L_BRACE         shift and go to state 162


state 123

    (79) simple_if -> IF L_PAREN expr . R_PAREN block
    R_PAREN         shift and go to state 163


state 124

    (24) expr -> t_expr OR expr .
    NEWLINE         reduce using rule 24 (expr -> t_expr OR expr .)
    SEMICOLON       reduce using rule 24 (expr -> t_expr OR expr .)
    $end            reduce using rule 24 (expr -> t_expr OR expr .)
    R_PAREN         reduce using rule 24 (expr -> t_expr OR expr .)
    COMMA           reduce using rule 24 (expr -> t_expr OR expr .)
    R_BRACKET       reduce using rule 24 (expr -> t_expr OR expr .)


state 125

    (26) t_expr -> g_expr AND t_expr .
    OR              reduce using rule 26 (t_expr -> g_expr AND t_expr .)
    NEWLINE         reduce using rule 26 (t_expr -> g_expr AND t_expr .)
    SEMICOLON       reduce using rule 26 (t_expr -> g_expr AND t_expr .)
    $end            reduce using rule 26 (t_expr -> g_expr AND t_expr .)
    R_PAREN         reduce using rule 26 (t_expr -> g_expr AND t_expr .)
    COMMA           reduce using rule 26 (t_expr -> g_expr AND t_expr .)
    R_BRACKET       reduce using rule 26 (t_expr -> g_expr AND t_expr .)


state 126

    (28) g_expr -> m_expr comparison m_expr .
    AND             reduce using rule 28 (g_expr -> m_expr comparison m_expr .)
    OR              reduce using rule 28 (g_expr -> m_expr comparison m_expr .)
    NEWLINE         reduce using rule 28 (g_expr -> m_expr comparison m_expr .)
    SEMICOLON       reduce using rule 28 (g_expr -> m_expr comparison m_expr .)
    $end            reduce using rule 28 (g_expr -> m_expr comparison m_expr .)
    R_PAREN         reduce using rule 28 (g_expr -> m_expr comparison m_expr .)
    COMMA           reduce using rule 28 (g_expr -> m_expr comparison m_expr .)
    R_BRACKET       reduce using rule 28 (g_expr -> m_expr comparison m_expr .)


state 127

    (36) m_expr -> term MINUS m_expr .
    LEQT            reduce using rule 36 (m_expr -> term MINUS m_expr .)
    GEQT            reduce using rule 36 (m_expr -> term MINUS m_expr .)
    LT              reduce using rule 36 (m_expr -> term MINUS m_expr .)
    GT              reduce using rule 36 (m_expr -> term MINUS m_expr .)
    NOT_EQ          reduce using rule 36 (m_expr -> term MINUS m_expr .)
    EQ              reduce using rule 36 (m_expr -> term MINUS m_expr .)
    AND             reduce using rule 36 (m_expr -> term MINUS m_expr .)
    OR              reduce using rule 36 (m_expr -> term MINUS m_expr .)
    NEWLINE         reduce using rule 36 (m_expr -> term MINUS m_expr .)
    SEMICOLON       reduce using rule 36 (m_expr -> term MINUS m_expr .)
    $end            reduce using rule 36 (m_expr -> term MINUS m_expr .)
    R_PAREN         reduce using rule 36 (m_expr -> term MINUS m_expr .)
    COMMA           reduce using rule 36 (m_expr -> term MINUS m_expr .)
    R_BRACKET       reduce using rule 36 (m_expr -> term MINUS m_expr .)


state 128

    (37) m_expr -> term PLUS m_expr .
    LEQT            reduce using rule 37 (m_expr -> term PLUS m_expr .)
    GEQT            reduce using rule 37 (m_expr -> term PLUS m_expr .)
    LT              reduce using rule 37 (m_expr -> term PLUS m_expr .)
    GT              reduce using rule 37 (m_expr -> term PLUS m_expr .)
    NOT_EQ          reduce using rule 37 (m_expr -> term PLUS m_expr .)
    EQ              reduce using rule 37 (m_expr -> term PLUS m_expr .)
    AND             reduce using rule 37 (m_expr -> term PLUS m_expr .)
    OR              reduce using rule 37 (m_expr -> term PLUS m_expr .)
    NEWLINE         reduce using rule 37 (m_expr -> term PLUS m_expr .)
    SEMICOLON       reduce using rule 37 (m_expr -> term PLUS m_expr .)
    $end            reduce using rule 37 (m_expr -> term PLUS m_expr .)
    R_PAREN         reduce using rule 37 (m_expr -> term PLUS m_expr .)
    COMMA           reduce using rule 37 (m_expr -> term PLUS m_expr .)
    R_BRACKET       reduce using rule 37 (m_expr -> term PLUS m_expr .)


state 129

    (39) term -> exp_factor MOD term .
    MINUS           reduce using rule 39 (term -> exp_factor MOD term .)
    PLUS            reduce using rule 39 (term -> exp_factor MOD term .)
    LEQT            reduce using rule 39 (term -> exp_factor MOD term .)
    GEQT            reduce using rule 39 (term -> exp_factor MOD term .)
    LT              reduce using rule 39 (term -> exp_factor MOD term .)
    GT              reduce using rule 39 (term -> exp_factor MOD term .)
    NOT_EQ          reduce using rule 39 (term -> exp_factor MOD term .)
    EQ              reduce using rule 39 (term -> exp_factor MOD term .)
    AND             reduce using rule 39 (term -> exp_factor MOD term .)
    OR              reduce using rule 39 (term -> exp_factor MOD term .)
    NEWLINE         reduce using rule 39 (term -> exp_factor MOD term .)
    SEMICOLON       reduce using rule 39 (term -> exp_factor MOD term .)
    $end            reduce using rule 39 (term -> exp_factor MOD term .)
    R_PAREN         reduce using rule 39 (term -> exp_factor MOD term .)
    COMMA           reduce using rule 39 (term -> exp_factor MOD term .)
    R_BRACKET       reduce using rule 39 (term -> exp_factor MOD term .)


state 130

    (40) term -> exp_factor DIV term .
    MINUS           reduce using rule 40 (term -> exp_factor DIV term .)
    PLUS            reduce using rule 40 (term -> exp_factor DIV term .)
    LEQT            reduce using rule 40 (term -> exp_factor DIV term .)
    GEQT            reduce using rule 40 (term -> exp_factor DIV term .)
    LT              reduce using rule 40 (term -> exp_factor DIV term .)
    GT              reduce using rule 40 (term -> exp_factor DIV term .)
    NOT_EQ          reduce using rule 40 (term -> exp_factor DIV term .)
    EQ              reduce using rule 40 (term -> exp_factor DIV term .)
    AND             reduce using rule 40 (term -> exp_factor DIV term .)
    OR              reduce using rule 40 (term -> exp_factor DIV term .)
    NEWLINE         reduce using rule 40 (term -> exp_factor DIV term .)
    SEMICOLON       reduce using rule 40 (term -> exp_factor DIV term .)
    $end            reduce using rule 40 (term -> exp_factor DIV term .)
    R_PAREN         reduce using rule 40 (term -> exp_factor DIV term .)
    COMMA           reduce using rule 40 (term -> exp_factor DIV term .)
    R_BRACKET       reduce using rule 40 (term -> exp_factor DIV term .)


state 131

    (41) term -> exp_factor MULT term .
    MINUS           reduce using rule 41 (term -> exp_factor MULT term .)
    PLUS            reduce using rule 41 (term -> exp_factor MULT term .)
    LEQT            reduce using rule 41 (term -> exp_factor MULT term .)
    GEQT            reduce using rule 41 (term -> exp_factor MULT term .)
    LT              reduce using rule 41 (term -> exp_factor MULT term .)
    GT              reduce using rule 41 (term -> exp_factor MULT term .)
    NOT_EQ          reduce using rule 41 (term -> exp_factor MULT term .)
    EQ              reduce using rule 41 (term -> exp_factor MULT term .)
    AND             reduce using rule 41 (term -> exp_factor MULT term .)
    OR              reduce using rule 41 (term -> exp_factor MULT term .)
    NEWLINE         reduce using rule 41 (term -> exp_factor MULT term .)
    SEMICOLON       reduce using rule 41 (term -> exp_factor MULT term .)
    $end            reduce using rule 41 (term -> exp_factor MULT term .)
    R_PAREN         reduce using rule 41 (term -> exp_factor MULT term .)
    COMMA           reduce using rule 41 (term -> exp_factor MULT term .)
    R_BRACKET       reduce using rule 41 (term -> exp_factor MULT term .)


state 132

    (43) exp_factor -> factor EXP exp_factor .
    MOD             reduce using rule 43 (exp_factor -> factor EXP exp_factor .)
    DIV             reduce using rule 43 (exp_factor -> factor EXP exp_factor .)
    MULT            reduce using rule 43 (exp_factor -> factor EXP exp_factor .)
    MINUS           reduce using rule 43 (exp_factor -> factor EXP exp_factor .)
    PLUS            reduce using rule 43 (exp_factor -> factor EXP exp_factor .)
    LEQT            reduce using rule 43 (exp_factor -> factor EXP exp_factor .)
    GEQT            reduce using rule 43 (exp_factor -> factor EXP exp_factor .)
    LT              reduce using rule 43 (exp_factor -> factor EXP exp_factor .)
    GT              reduce using rule 43 (exp_factor -> factor EXP exp_factor .)
    NOT_EQ          reduce using rule 43 (exp_factor -> factor EXP exp_factor .)
    EQ              reduce using rule 43 (exp_factor -> factor EXP exp_factor .)
    AND             reduce using rule 43 (exp_factor -> factor EXP exp_factor .)
    OR              reduce using rule 43 (exp_factor -> factor EXP exp_factor .)
    NEWLINE         reduce using rule 43 (exp_factor -> factor EXP exp_factor .)
    SEMICOLON       reduce using rule 43 (exp_factor -> factor EXP exp_factor .)
    $end            reduce using rule 43 (exp_factor -> factor EXP exp_factor .)
    R_PAREN         reduce using rule 43 (exp_factor -> factor EXP exp_factor .)
    COMMA           reduce using rule 43 (exp_factor -> factor EXP exp_factor .)
    R_BRACKET       reduce using rule 43 (exp_factor -> factor EXP exp_factor .)


state 133

    (13) tens_id -> ID L_BRACKET expr . R_BRACKET
    R_BRACKET       shift and go to state 164


state 134

    (12) tens_id -> tens_id L_BRACKET expr . R_BRACKET
    R_BRACKET       shift and go to state 165


state 135

    (56) factor_1 -> L_PAREN expr R_PAREN .
    EXP             reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    MOD             reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    DIV             reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    MULT            reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    LEQT            reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    GEQT            reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    LT              reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    GT              reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    NOT_EQ          reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    EQ              reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    AND             reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    OR              reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    NEWLINE         reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    SEMICOLON       reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    $end            reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    R_PAREN         reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    COMMA           reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)
    R_BRACKET       reduce using rule 56 (factor_1 -> L_PAREN expr R_PAREN .)


state 136

    (59) read_file -> READ_FILE L_PAREN expr . R_PAREN
    R_PAREN         shift and go to state 166


state 137

    (57) read_line -> READ_LINE L_PAREN R_PAREN .
    EXP             reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    MOD             reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    DIV             reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    MULT            reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    MINUS           reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    PLUS            reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    LEQT            reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    GEQT            reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    LT              reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    GT              reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    NOT_EQ          reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    EQ              reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    AND             reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    OR              reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    NEWLINE         reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    SEMICOLON       reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    $end            reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    R_PAREN         reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    COMMA           reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)
    R_BRACKET       reduce using rule 57 (read_line -> READ_LINE L_PAREN R_PAREN .)


state 138

    (9) tens -> L_BRACKET expr tens_1 .
    EXP             reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    MOD             reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    DIV             reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    MULT            reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    MINUS           reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    PLUS            reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    LEQT            reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    GEQT            reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    LT              reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    GT              reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    NOT_EQ          reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    EQ              reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    AND             reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    OR              reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    NEWLINE         reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    SEMICOLON       reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    $end            reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    R_PAREN         reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    COMMA           reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)
    R_BRACKET       reduce using rule 9 (tens -> L_BRACKET expr tens_1 .)


state 139

    (10) tens_1 -> COMMA . expr tens_1
    (24) expr -> . t_expr OR expr
    (25) expr -> . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    expr                           shift and go to state 167
    t_expr                         shift and go to state 38
    g_expr                         shift and go to state 39
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 140

    (11) tens_1 -> R_BRACKET .
    EXP             reduce using rule 11 (tens_1 -> R_BRACKET .)
    MOD             reduce using rule 11 (tens_1 -> R_BRACKET .)
    DIV             reduce using rule 11 (tens_1 -> R_BRACKET .)
    MULT            reduce using rule 11 (tens_1 -> R_BRACKET .)
    MINUS           reduce using rule 11 (tens_1 -> R_BRACKET .)
    PLUS            reduce using rule 11 (tens_1 -> R_BRACKET .)
    LEQT            reduce using rule 11 (tens_1 -> R_BRACKET .)
    GEQT            reduce using rule 11 (tens_1 -> R_BRACKET .)
    LT              reduce using rule 11 (tens_1 -> R_BRACKET .)
    GT              reduce using rule 11 (tens_1 -> R_BRACKET .)
    NOT_EQ          reduce using rule 11 (tens_1 -> R_BRACKET .)
    EQ              reduce using rule 11 (tens_1 -> R_BRACKET .)
    AND             reduce using rule 11 (tens_1 -> R_BRACKET .)
    OR              reduce using rule 11 (tens_1 -> R_BRACKET .)
    NEWLINE         reduce using rule 11 (tens_1 -> R_BRACKET .)
    SEMICOLON       reduce using rule 11 (tens_1 -> R_BRACKET .)
    $end            reduce using rule 11 (tens_1 -> R_BRACKET .)
    R_PAREN         reduce using rule 11 (tens_1 -> R_BRACKET .)
    COMMA           reduce using rule 11 (tens_1 -> R_BRACKET .)
    R_BRACKET       reduce using rule 11 (tens_1 -> R_BRACKET .)


state 141

    (62) func_call_1 -> expr COMMA . func_call_1
    (62) func_call_1 -> . expr COMMA func_call_1
    (63) func_call_1 -> . expr R_PAREN
    (64) func_call_1 -> . R_PAREN
    (24) expr -> . t_expr OR expr
    (25) expr -> . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    R_PAREN         shift and go to state 107
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    expr                           shift and go to state 106
    func_call_1                    shift and go to state 168
    t_expr                         shift and go to state 38
    g_expr                         shift and go to state 39
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 142

    (63) func_call_1 -> expr R_PAREN .
    NEWLINE         reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    SEMICOLON       reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    $end            reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    EXP             reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    MOD             reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    DIV             reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    MULT            reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    MINUS           reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    PLUS            reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    LEQT            reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    GEQT            reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    LT              reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    GT              reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    NOT_EQ          reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    EQ              reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    AND             reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    OR              reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    R_PAREN         reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    COMMA           reduce using rule 63 (func_call_1 -> expr R_PAREN .)
    R_BRACKET       reduce using rule 63 (func_call_1 -> expr R_PAREN .)


state 143

    (91) func_params_1 -> ID . COLON const_type COMMA func_params_1
    (92) func_params_1 -> ID . COLON const_type
    COLON           shift and go to state 169


state 144

    (88) func -> LET ID L_PAREN func_params . R_PAREN COLON func_type block
    R_PAREN         shift and go to state 170


state 145

    (89) func_params -> empty .
    R_PAREN         reduce using rule 89 (func_params -> empty .)


state 146

    (90) func_params -> func_params_1 .
    R_PAREN         reduce using rule 90 (func_params -> func_params_1 .)


state 147

    (67) var_1 -> var_2 COMMA var_1 .
    NEWLINE         reduce using rule 67 (var_1 -> var_2 COMMA var_1 .)
    SEMICOLON       reduce using rule 67 (var_1 -> var_2 COMMA var_1 .)
    $end            reduce using rule 67 (var_1 -> var_2 COMMA var_1 .)


state 148

    (73) var_id -> ID .
    COLON           reduce using rule 73 (var_id -> ID .)
    L_BRACKET       reduce using rule 73 (var_id -> ID .)


state 149

    (69) var_2 -> var_3 ASSIG expr .
    COMMA           reduce using rule 69 (var_2 -> var_3 ASSIG expr .)
    NEWLINE         reduce using rule 69 (var_2 -> var_3 ASSIG expr .)
    SEMICOLON       reduce using rule 69 (var_2 -> var_3 ASSIG expr .)
    $end            reduce using rule 69 (var_2 -> var_3 ASSIG expr .)


state 150

    (71) var_3 -> var_id COLON const_type .
    ASSIG           reduce using rule 71 (var_3 -> var_id COLON const_type .)
    COMMA           reduce using rule 71 (var_3 -> var_id COLON const_type .)
    NEWLINE         reduce using rule 71 (var_3 -> var_id COLON const_type .)
    SEMICOLON       reduce using rule 71 (var_3 -> var_id COLON const_type .)
    $end            reduce using rule 71 (var_3 -> var_id COLON const_type .)


state 151

    (17) const_type -> GPU_BOOL_T .
    ASSIG           reduce using rule 17 (const_type -> GPU_BOOL_T .)
    COMMA           reduce using rule 17 (const_type -> GPU_BOOL_T .)
    NEWLINE         reduce using rule 17 (const_type -> GPU_BOOL_T .)
    SEMICOLON       reduce using rule 17 (const_type -> GPU_BOOL_T .)
    $end            reduce using rule 17 (const_type -> GPU_BOOL_T .)
    R_PAREN         reduce using rule 17 (const_type -> GPU_BOOL_T .)
    L_BRACE         reduce using rule 17 (const_type -> GPU_BOOL_T .)


state 152

    (18) const_type -> GPU_FLOAT_T .
    ASSIG           reduce using rule 18 (const_type -> GPU_FLOAT_T .)
    COMMA           reduce using rule 18 (const_type -> GPU_FLOAT_T .)
    NEWLINE         reduce using rule 18 (const_type -> GPU_FLOAT_T .)
    SEMICOLON       reduce using rule 18 (const_type -> GPU_FLOAT_T .)
    $end            reduce using rule 18 (const_type -> GPU_FLOAT_T .)
    R_PAREN         reduce using rule 18 (const_type -> GPU_FLOAT_T .)
    L_BRACE         reduce using rule 18 (const_type -> GPU_FLOAT_T .)


state 153

    (19) const_type -> GPU_INT_T .
    ASSIG           reduce using rule 19 (const_type -> GPU_INT_T .)
    COMMA           reduce using rule 19 (const_type -> GPU_INT_T .)
    NEWLINE         reduce using rule 19 (const_type -> GPU_INT_T .)
    SEMICOLON       reduce using rule 19 (const_type -> GPU_INT_T .)
    $end            reduce using rule 19 (const_type -> GPU_INT_T .)
    R_PAREN         reduce using rule 19 (const_type -> GPU_INT_T .)
    L_BRACE         reduce using rule 19 (const_type -> GPU_INT_T .)


state 154

    (20) const_type -> BOOL_T .
    ASSIG           reduce using rule 20 (const_type -> BOOL_T .)
    COMMA           reduce using rule 20 (const_type -> BOOL_T .)
    NEWLINE         reduce using rule 20 (const_type -> BOOL_T .)
    SEMICOLON       reduce using rule 20 (const_type -> BOOL_T .)
    $end            reduce using rule 20 (const_type -> BOOL_T .)
    R_PAREN         reduce using rule 20 (const_type -> BOOL_T .)
    L_BRACE         reduce using rule 20 (const_type -> BOOL_T .)


state 155

    (21) const_type -> STRING_T .
    ASSIG           reduce using rule 21 (const_type -> STRING_T .)
    COMMA           reduce using rule 21 (const_type -> STRING_T .)
    NEWLINE         reduce using rule 21 (const_type -> STRING_T .)
    SEMICOLON       reduce using rule 21 (const_type -> STRING_T .)
    $end            reduce using rule 21 (const_type -> STRING_T .)
    R_PAREN         reduce using rule 21 (const_type -> STRING_T .)
    L_BRACE         reduce using rule 21 (const_type -> STRING_T .)


state 156

    (22) const_type -> FLOAT_T .
    ASSIG           reduce using rule 22 (const_type -> FLOAT_T .)
    COMMA           reduce using rule 22 (const_type -> FLOAT_T .)
    NEWLINE         reduce using rule 22 (const_type -> FLOAT_T .)
    SEMICOLON       reduce using rule 22 (const_type -> FLOAT_T .)
    $end            reduce using rule 22 (const_type -> FLOAT_T .)
    R_PAREN         reduce using rule 22 (const_type -> FLOAT_T .)
    L_BRACE         reduce using rule 22 (const_type -> FLOAT_T .)


state 157

    (23) const_type -> INT_T .
    ASSIG           reduce using rule 23 (const_type -> INT_T .)
    COMMA           reduce using rule 23 (const_type -> INT_T .)
    NEWLINE         reduce using rule 23 (const_type -> INT_T .)
    SEMICOLON       reduce using rule 23 (const_type -> INT_T .)
    $end            reduce using rule 23 (const_type -> INT_T .)
    R_PAREN         reduce using rule 23 (const_type -> INT_T .)
    L_BRACE         reduce using rule 23 (const_type -> INT_T .)


state 158

    (72) var_id -> var_id L_BRACKET INT_V . R_BRACKET
    R_BRACKET       shift and go to state 171


state 159

    (75) for_loop -> FOR L_PAREN var SEMICOLON . expr SEMICOLON assign R_PAREN block
    (24) expr -> . t_expr OR expr
    (25) expr -> . t_expr
    (26) t_expr -> . g_expr AND t_expr
    (27) t_expr -> . g_expr
    (28) g_expr -> . m_expr comparison m_expr
    (29) g_expr -> . m_expr
    (36) m_expr -> . term MINUS m_expr
    (37) m_expr -> . term PLUS m_expr
    (38) m_expr -> . term
    (39) term -> . exp_factor MOD term
    (40) term -> . exp_factor DIV term
    (41) term -> . exp_factor MULT term
    (42) term -> . exp_factor
    (43) exp_factor -> . factor EXP exp_factor
    (44) exp_factor -> . factor
    (45) factor -> . MINUS factor_1
    (46) factor -> . PLUS factor_1
    (47) factor -> . NOT factor_1
    (48) factor -> . factor_1
    (49) factor_1 -> . ID
    (50) factor_1 -> . read_file
    (51) factor_1 -> . read_line
    (52) factor_1 -> . tens_id
    (53) factor_1 -> . tens
    (54) factor_1 -> . func_call
    (55) factor_1 -> . const
    (56) factor_1 -> . L_PAREN expr R_PAREN
    (59) read_file -> . READ_FILE L_PAREN expr R_PAREN
    (57) read_line -> . READ_LINE L_PAREN R_PAREN
    (12) tens_id -> . tens_id L_BRACKET expr R_BRACKET
    (13) tens_id -> . ID L_BRACKET expr R_BRACKET
    (9) tens -> . L_BRACKET expr tens_1
    (61) func_call -> . ID L_PAREN func_call_1
    (5) const -> . STRING_V
    (6) const -> . BOOL_V
    (7) const -> . FLOAT_V
    (8) const -> . INT_V
    MINUS           shift and go to state 42
    PLUS            shift and go to state 43
    NOT             shift and go to state 47
    ID              shift and go to state 48
    L_PAREN         shift and go to state 55
    READ_FILE       shift and go to state 56
    READ_LINE       shift and go to state 57
    L_BRACKET       shift and go to state 58
    STRING_V        shift and go to state 59
    BOOL_V          shift and go to state 60
    FLOAT_V         shift and go to state 61
    INT_V           shift and go to state 62

    expr                           shift and go to state 172
    t_expr                         shift and go to state 38
    g_expr                         shift and go to state 39
    m_expr                         shift and go to state 40
    term                           shift and go to state 41
    exp_factor                     shift and go to state 44
    factor                         shift and go to state 45
    factor_1                       shift and go to state 46
    read_file                      shift and go to state 49
    read_line                      shift and go to state 50
    tens_id                        shift and go to state 51
    tens                           shift and go to state 52
    func_call                      shift and go to state 53
    const                          shift and go to state 54

state 160

    (74) while_loop -> WHILE L_PAREN expr R_PAREN . block
    (14) block -> . ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines
    (110) ignored_newlines -> . empty
    (111) ignored_newlines -> . NEWLINE ignored_newlines
    (112) empty -> .
    NEWLINE         shift and go to state 4
    L_BRACE         reduce using rule 112 (empty -> .)

    block                          shift and go to state 173
    ignored_newlines               shift and go to state 122
    empty                          shift and go to state 3

state 161

    (81) simple_else_if -> ELSE_IF L_PAREN expr . R_PAREN block complex_else_if
    R_PAREN         shift and go to state 174


state 162

    (14) block -> ignored_newlines L_BRACE . ignored_newlines block_1 R_BRACE ignored_newlines
    (110) ignored_newlines -> . empty
    (111) ignored_newlines -> . NEWLINE ignored_newlines
    (112) empty -> .
    NEWLINE         shift and go to state 4
    LET             reduce using rule 112 (empty -> .)
    FOR             reduce using rule 112 (empty -> .)
    WHILE           reduce using rule 112 (empty -> .)
    RETURN          reduce using rule 112 (empty -> .)
    ID              reduce using rule 112 (empty -> .)
    WRITE_FILE      reduce using rule 112 (empty -> .)
    PRINT           reduce using rule 112 (empty -> .)
    IF              reduce using rule 112 (empty -> .)
    R_BRACE         reduce using rule 112 (empty -> .)

    ignored_newlines               shift and go to state 175
    empty                          shift and go to state 3

state 163

    (79) simple_if -> IF L_PAREN expr R_PAREN . block
    (14) block -> . ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines
    (110) ignored_newlines -> . empty
    (111) ignored_newlines -> . NEWLINE ignored_newlines
    (112) empty -> .
    NEWLINE         shift and go to state 4
    L_BRACE         reduce using rule 112 (empty -> .)

    block                          shift and go to state 176
    ignored_newlines               shift and go to state 122
    empty                          shift and go to state 3

state 164

    (13) tens_id -> ID L_BRACKET expr R_BRACKET .
    L_BRACKET       reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    EXP             reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    MOD             reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    DIV             reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    MULT            reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    MINUS           reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    PLUS            reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    LEQT            reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    GEQT            reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    LT              reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    GT              reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    NOT_EQ          reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    EQ              reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    AND             reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    OR              reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    NEWLINE         reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    SEMICOLON       reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    $end            reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    R_PAREN         reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    COMMA           reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)
    R_BRACKET       reduce using rule 13 (tens_id -> ID L_BRACKET expr R_BRACKET .)


state 165

    (12) tens_id -> tens_id L_BRACKET expr R_BRACKET .
    L_BRACKET       reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    EXP             reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    MOD             reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    DIV             reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    MULT            reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    MINUS           reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    PLUS            reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    LEQT            reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    GEQT            reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    LT              reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    GT              reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    NOT_EQ          reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    EQ              reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    AND             reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    OR              reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    NEWLINE         reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    SEMICOLON       reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    $end            reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    R_PAREN         reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    COMMA           reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)
    R_BRACKET       reduce using rule 12 (tens_id -> tens_id L_BRACKET expr R_BRACKET .)


state 166

    (59) read_file -> READ_FILE L_PAREN expr R_PAREN .
    EXP             reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    MOD             reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    DIV             reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    MULT            reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    LEQT            reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    GEQT            reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    LT              reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    GT              reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    NOT_EQ          reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    EQ              reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    AND             reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    OR              reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    NEWLINE         reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    SEMICOLON       reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    $end            reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    R_PAREN         reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    COMMA           reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)
    R_BRACKET       reduce using rule 59 (read_file -> READ_FILE L_PAREN expr R_PAREN .)


state 167

    (10) tens_1 -> COMMA expr . tens_1
    (10) tens_1 -> . COMMA expr tens_1
    (11) tens_1 -> . R_BRACKET
    COMMA           shift and go to state 139
    R_BRACKET       shift and go to state 140

    tens_1                         shift and go to state 177

state 168

    (62) func_call_1 -> expr COMMA func_call_1 .
    NEWLINE         reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    SEMICOLON       reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    $end            reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    EXP             reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    MOD             reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    DIV             reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    MULT            reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    MINUS           reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    PLUS            reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    LEQT            reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    GEQT            reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    LT              reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    GT              reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    NOT_EQ          reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    EQ              reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    AND             reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    OR              reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    R_PAREN         reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    COMMA           reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)
    R_BRACKET       reduce using rule 62 (func_call_1 -> expr COMMA func_call_1 .)


state 169

    (91) func_params_1 -> ID COLON . const_type COMMA func_params_1
    (92) func_params_1 -> ID COLON . const_type
    (17) const_type -> . GPU_BOOL_T
    (18) const_type -> . GPU_FLOAT_T
    (19) const_type -> . GPU_INT_T
    (20) const_type -> . BOOL_T
    (21) const_type -> . STRING_T
    (22) const_type -> . FLOAT_T
    (23) const_type -> . INT_T
    GPU_BOOL_T      shift and go to state 151
    GPU_FLOAT_T     shift and go to state 152
    GPU_INT_T       shift and go to state 153
    BOOL_T          shift and go to state 154
    STRING_T        shift and go to state 155
    FLOAT_T         shift and go to state 156
    INT_T           shift and go to state 157

    const_type                     shift and go to state 178

state 170

    (88) func -> LET ID L_PAREN func_params R_PAREN . COLON func_type block
    COLON           shift and go to state 179


state 171

    (72) var_id -> var_id L_BRACKET INT_V R_BRACKET .
    COLON           reduce using rule 72 (var_id -> var_id L_BRACKET INT_V R_BRACKET .)
    L_BRACKET       reduce using rule 72 (var_id -> var_id L_BRACKET INT_V R_BRACKET .)


state 172

    (75) for_loop -> FOR L_PAREN var SEMICOLON expr . SEMICOLON assign R_PAREN block
    SEMICOLON       shift and go to state 180


state 173

    (74) while_loop -> WHILE L_PAREN expr R_PAREN block .
    RETURN          reduce using rule 74 (while_loop -> WHILE L_PAREN expr R_PAREN block .)
    ID              reduce using rule 74 (while_loop -> WHILE L_PAREN expr R_PAREN block .)
    WRITE_FILE      reduce using rule 74 (while_loop -> WHILE L_PAREN expr R_PAREN block .)
    PRINT           reduce using rule 74 (while_loop -> WHILE L_PAREN expr R_PAREN block .)
    LET             reduce using rule 74 (while_loop -> WHILE L_PAREN expr R_PAREN block .)
    FOR             reduce using rule 74 (while_loop -> WHILE L_PAREN expr R_PAREN block .)
    WHILE           reduce using rule 74 (while_loop -> WHILE L_PAREN expr R_PAREN block .)
    IF              reduce using rule 74 (while_loop -> WHILE L_PAREN expr R_PAREN block .)
    $end            reduce using rule 74 (while_loop -> WHILE L_PAREN expr R_PAREN block .)
    R_BRACE         reduce using rule 74 (while_loop -> WHILE L_PAREN expr R_PAREN block .)


state 174

    (81) simple_else_if -> ELSE_IF L_PAREN expr R_PAREN . block complex_else_if
    (14) block -> . ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines
    (110) ignored_newlines -> . empty
    (111) ignored_newlines -> . NEWLINE ignored_newlines
    (112) empty -> .
    NEWLINE         shift and go to state 4
    L_BRACE         reduce using rule 112 (empty -> .)

    block                          shift and go to state 181
    ignored_newlines               shift and go to state 122
    empty                          shift and go to state 3

state 175

    (14) block -> ignored_newlines L_BRACE ignored_newlines . block_1 R_BRACE ignored_newlines
    (15) block_1 -> . empty
    (16) block_1 -> . statement block_1
    (112) empty -> .
    (96) statement -> . block_statements
    (97) statement -> . statements eos
    (104) block_statements -> . func
    (105) block_statements -> . cond
    (106) block_statements -> . for_loop
    (107) block_statements -> . while_loop
    (98) statements -> . ret
    (99) statements -> . func_call
    (100) statements -> . write_file
    (101) statements -> . print_rule
    (102) statements -> . assign
    (103) statements -> . var
    (88) func -> . LET ID L_PAREN func_params R_PAREN COLON func_type block
    (76) cond -> . cond_if_else_if
    (77) cond -> . cond_if_else
    (78) cond -> . cond_if
    (75) for_loop -> . FOR L_PAREN var SEMICOLON expr SEMICOLON assign R_PAREN block
    (74) while_loop -> . WHILE L_PAREN expr R_PAREN block
    (95) ret -> . RETURN expr
    (61) func_call -> . ID L_PAREN func_call_1
    (60) write_file -> . WRITE_FILE L_PAREN func_call_1
    (58) print_rule -> . PRINT L_PAREN func_call_1
    (65) assign -> . ID ASSIG expr
    (66) var -> . LET var_1
    (86) cond_if_else_if -> . simple_if simple_else_if simple_else
    (87) cond_if_else_if -> . simple_if simple_else_if
    (85) cond_if_else -> . simple_if simple_else
    (84) cond_if -> . simple_if
    (79) simple_if -> . IF L_PAREN expr R_PAREN block
    R_BRACE         reduce using rule 112 (empty -> .)
    LET             shift and go to state 186
    FOR             shift and go to state 28
    WHILE           shift and go to state 29
    RETURN          shift and go to state 16
    ID              shift and go to state 17
    WRITE_FILE      shift and go to state 18
    PRINT           shift and go to state 19
    IF              shift and go to state 31

    block_1                        shift and go to state 182
    empty                          shift and go to state 183
    statement                      shift and go to state 184
    block_statements               shift and go to state 15
    statements                     shift and go to state 185
    func                           shift and go to state 21
    cond                           shift and go to state 22
    for_loop                       shift and go to state 23
    while_loop                     shift and go to state 24
    ret                            shift and go to state 9
    func_call                      shift and go to state 10
    write_file                     shift and go to state 11
    print_rule                     shift and go to state 12
    assign                         shift and go to state 13
    var                            shift and go to state 14
    cond_if_else_if                shift and go to state 25
    cond_if_else                   shift and go to state 26
    cond_if                        shift and go to state 27
    simple_if                      shift and go to state 30

state 176

    (79) simple_if -> IF L_PAREN expr R_PAREN block .
    ELSE_IF         reduce using rule 79 (simple_if -> IF L_PAREN expr R_PAREN block .)
    ELSE            reduce using rule 79 (simple_if -> IF L_PAREN expr R_PAREN block .)
    RETURN          reduce using rule 79 (simple_if -> IF L_PAREN expr R_PAREN block .)
    ID              reduce using rule 79 (simple_if -> IF L_PAREN expr R_PAREN block .)
    WRITE_FILE      reduce using rule 79 (simple_if -> IF L_PAREN expr R_PAREN block .)
    PRINT           reduce using rule 79 (simple_if -> IF L_PAREN expr R_PAREN block .)
    LET             reduce using rule 79 (simple_if -> IF L_PAREN expr R_PAREN block .)
    FOR             reduce using rule 79 (simple_if -> IF L_PAREN expr R_PAREN block .)
    WHILE           reduce using rule 79 (simple_if -> IF L_PAREN expr R_PAREN block .)
    IF              reduce using rule 79 (simple_if -> IF L_PAREN expr R_PAREN block .)
    $end            reduce using rule 79 (simple_if -> IF L_PAREN expr R_PAREN block .)
    R_BRACE         reduce using rule 79 (simple_if -> IF L_PAREN expr R_PAREN block .)


state 177

    (10) tens_1 -> COMMA expr tens_1 .
    EXP             reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    MOD             reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    DIV             reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    MULT            reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    MINUS           reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    PLUS            reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    LEQT            reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    GEQT            reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    LT              reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    GT              reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    NOT_EQ          reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    EQ              reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    AND             reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    OR              reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    NEWLINE         reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    SEMICOLON       reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    $end            reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    R_PAREN         reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    COMMA           reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)
    R_BRACKET       reduce using rule 10 (tens_1 -> COMMA expr tens_1 .)


state 178

    (91) func_params_1 -> ID COLON const_type . COMMA func_params_1
    (92) func_params_1 -> ID COLON const_type .
    COMMA           shift and go to state 187
    R_PAREN         reduce using rule 92 (func_params_1 -> ID COLON const_type .)


state 179

    (88) func -> LET ID L_PAREN func_params R_PAREN COLON . func_type block
    (93) func_type -> . VOID
    (94) func_type -> . const_type
    (17) const_type -> . GPU_BOOL_T
    (18) const_type -> . GPU_FLOAT_T
    (19) const_type -> . GPU_INT_T
    (20) const_type -> . BOOL_T
    (21) const_type -> . STRING_T
    (22) const_type -> . FLOAT_T
    (23) const_type -> . INT_T
    VOID            shift and go to state 189
    GPU_BOOL_T      shift and go to state 151
    GPU_FLOAT_T     shift and go to state 152
    GPU_INT_T       shift and go to state 153
    BOOL_T          shift and go to state 154
    STRING_T        shift and go to state 155
    FLOAT_T         shift and go to state 156
    INT_T           shift and go to state 157

    func_type                      shift and go to state 188
    const_type                     shift and go to state 190

state 180

    (75) for_loop -> FOR L_PAREN var SEMICOLON expr SEMICOLON . assign R_PAREN block
    (65) assign -> . ID ASSIG expr
    ID              shift and go to state 192

    assign                         shift and go to state 191

state 181

    (81) simple_else_if -> ELSE_IF L_PAREN expr R_PAREN block . complex_else_if
    (82) complex_else_if -> . empty
    (83) complex_else_if -> . simple_else_if
    (112) empty -> .
    (81) simple_else_if -> . ELSE_IF L_PAREN expr R_PAREN block complex_else_if
    ELSE            reduce using rule 112 (empty -> .)
    RETURN          reduce using rule 112 (empty -> .)
    ID              reduce using rule 112 (empty -> .)
    WRITE_FILE      reduce using rule 112 (empty -> .)
    PRINT           reduce using rule 112 (empty -> .)
    LET             reduce using rule 112 (empty -> .)
    FOR             reduce using rule 112 (empty -> .)
    WHILE           reduce using rule 112 (empty -> .)
    IF              reduce using rule 112 (empty -> .)
    $end            reduce using rule 112 (empty -> .)
    R_BRACE         reduce using rule 112 (empty -> .)
    ELSE_IF         shift and go to state 76

    complex_else_if                shift and go to state 193
    empty                          shift and go to state 194
    simple_else_if                 shift and go to state 195

state 182

    (14) block -> ignored_newlines L_BRACE ignored_newlines block_1 . R_BRACE ignored_newlines
    R_BRACE         shift and go to state 196


state 183

    (15) block_1 -> empty .
    R_BRACE         reduce using rule 15 (block_1 -> empty .)


state 184

    (16) block_1 -> statement . block_1
    (15) block_1 -> . empty
    (16) block_1 -> . statement block_1
    (112) empty -> .
    (96) statement -> . block_statements
    (97) statement -> . statements eos
    (104) block_statements -> . func
    (105) block_statements -> . cond
    (106) block_statements -> . for_loop
    (107) block_statements -> . while_loop
    (98) statements -> . ret
    (99) statements -> . func_call
    (100) statements -> . write_file
    (101) statements -> . print_rule
    (102) statements -> . assign
    (103) statements -> . var
    (88) func -> . LET ID L_PAREN func_params R_PAREN COLON func_type block
    (76) cond -> . cond_if_else_if
    (77) cond -> . cond_if_else
    (78) cond -> . cond_if
    (75) for_loop -> . FOR L_PAREN var SEMICOLON expr SEMICOLON assign R_PAREN block
    (74) while_loop -> . WHILE L_PAREN expr R_PAREN block
    (95) ret -> . RETURN expr
    (61) func_call -> . ID L_PAREN func_call_1
    (60) write_file -> . WRITE_FILE L_PAREN func_call_1
    (58) print_rule -> . PRINT L_PAREN func_call_1
    (65) assign -> . ID ASSIG expr
    (66) var -> . LET var_1
    (86) cond_if_else_if -> . simple_if simple_else_if simple_else
    (87) cond_if_else_if -> . simple_if simple_else_if
    (85) cond_if_else -> . simple_if simple_else
    (84) cond_if -> . simple_if
    (79) simple_if -> . IF L_PAREN expr R_PAREN block
    R_BRACE         reduce using rule 112 (empty -> .)
    LET             shift and go to state 186
    FOR             shift and go to state 28
    WHILE           shift and go to state 29
    RETURN          shift and go to state 16
    ID              shift and go to state 17
    WRITE_FILE      shift and go to state 18
    PRINT           shift and go to state 19
    IF              shift and go to state 31

    statement                      shift and go to state 184
    block_1                        shift and go to state 197
    empty                          shift and go to state 183
    block_statements               shift and go to state 15
    statements                     shift and go to state 185
    func                           shift and go to state 21
    cond                           shift and go to state 22
    for_loop                       shift and go to state 23
    while_loop                     shift and go to state 24
    ret                            shift and go to state 9
    func_call                      shift and go to state 10
    write_file                     shift and go to state 11
    print_rule                     shift and go to state 12
    assign                         shift and go to state 13
    var                            shift and go to state 14
    cond_if_else_if                shift and go to state 25
    cond_if_else                   shift and go to state 26
    cond_if                        shift and go to state 27
    simple_if                      shift and go to state 30

state 185

    (97) statement -> statements . eos
    (108) eos -> . NEWLINE ignored_newlines
    (109) eos -> . SEMICOLON ignored_newlines
    NEWLINE         shift and go to state 34
    SEMICOLON       shift and go to state 35

    eos                            shift and go to state 33

state 186

    (88) func -> LET . ID L_PAREN func_params R_PAREN COLON func_type block
    (66) var -> LET . var_1
    (67) var_1 -> . var_2 COMMA var_1
    (68) var_1 -> . var_2
    (69) var_2 -> . var_3 ASSIG expr
    (70) var_2 -> . var_3
    (71) var_3 -> . var_id COLON const_type
    (72) var_id -> . var_id L_BRACKET INT_V R_BRACKET
    (73) var_id -> . ID
    ID              shift and go to state 68

    var_1                          shift and go to state 67
    var_2                          shift and go to state 69
    var_3                          shift and go to state 70
    var_id                         shift and go to state 71

state 187

    (91) func_params_1 -> ID COLON const_type COMMA . func_params_1
    (91) func_params_1 -> . ID COLON const_type COMMA func_params_1
    (92) func_params_1 -> . ID COLON const_type
    ID              shift and go to state 143

    func_params_1                  shift and go to state 198

state 188

    (88) func -> LET ID L_PAREN func_params R_PAREN COLON func_type . block
    (14) block -> . ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines
    (110) ignored_newlines -> . empty
    (111) ignored_newlines -> . NEWLINE ignored_newlines
    (112) empty -> .
    NEWLINE         shift and go to state 4
    L_BRACE         reduce using rule 112 (empty -> .)

    block                          shift and go to state 199
    ignored_newlines               shift and go to state 122
    empty                          shift and go to state 3

state 189

    (93) func_type -> VOID .
    NEWLINE         reduce using rule 93 (func_type -> VOID .)
    L_BRACE         reduce using rule 93 (func_type -> VOID .)


state 190

    (94) func_type -> const_type .
    NEWLINE         reduce using rule 94 (func_type -> const_type .)
    L_BRACE         reduce using rule 94 (func_type -> const_type .)


state 191

    (75) for_loop -> FOR L_PAREN var SEMICOLON expr SEMICOLON assign . R_PAREN block
    R_PAREN         shift and go to state 200


state 192

    (65) assign -> ID . ASSIG expr
    ASSIG           shift and go to state 64


state 193

    (81) simple_else_if -> ELSE_IF L_PAREN expr R_PAREN block complex_else_if .
    ELSE            reduce using rule 81 (simple_else_if -> ELSE_IF L_PAREN expr R_PAREN block complex_else_if .)
    RETURN          reduce using rule 81 (simple_else_if -> ELSE_IF L_PAREN expr R_PAREN block complex_else_if .)
    ID              reduce using rule 81 (simple_else_if -> ELSE_IF L_PAREN expr R_PAREN block complex_else_if .)
    WRITE_FILE      reduce using rule 81 (simple_else_if -> ELSE_IF L_PAREN expr R_PAREN block complex_else_if .)
    PRINT           reduce using rule 81 (simple_else_if -> ELSE_IF L_PAREN expr R_PAREN block complex_else_if .)
    LET             reduce using rule 81 (simple_else_if -> ELSE_IF L_PAREN expr R_PAREN block complex_else_if .)
    FOR             reduce using rule 81 (simple_else_if -> ELSE_IF L_PAREN expr R_PAREN block complex_else_if .)
    WHILE           reduce using rule 81 (simple_else_if -> ELSE_IF L_PAREN expr R_PAREN block complex_else_if .)
    IF              reduce using rule 81 (simple_else_if -> ELSE_IF L_PAREN expr R_PAREN block complex_else_if .)
    $end            reduce using rule 81 (simple_else_if -> ELSE_IF L_PAREN expr R_PAREN block complex_else_if .)
    R_BRACE         reduce using rule 81 (simple_else_if -> ELSE_IF L_PAREN expr R_PAREN block complex_else_if .)


state 194

    (82) complex_else_if -> empty .
    ELSE            reduce using rule 82 (complex_else_if -> empty .)
    RETURN          reduce using rule 82 (complex_else_if -> empty .)
    ID              reduce using rule 82 (complex_else_if -> empty .)
    WRITE_FILE      reduce using rule 82 (complex_else_if -> empty .)
    PRINT           reduce using rule 82 (complex_else_if -> empty .)
    LET             reduce using rule 82 (complex_else_if -> empty .)
    FOR             reduce using rule 82 (complex_else_if -> empty .)
    WHILE           reduce using rule 82 (complex_else_if -> empty .)
    IF              reduce using rule 82 (complex_else_if -> empty .)
    $end            reduce using rule 82 (complex_else_if -> empty .)
    R_BRACE         reduce using rule 82 (complex_else_if -> empty .)


state 195

    (83) complex_else_if -> simple_else_if .
    ELSE            reduce using rule 83 (complex_else_if -> simple_else_if .)
    RETURN          reduce using rule 83 (complex_else_if -> simple_else_if .)
    ID              reduce using rule 83 (complex_else_if -> simple_else_if .)
    WRITE_FILE      reduce using rule 83 (complex_else_if -> simple_else_if .)
    PRINT           reduce using rule 83 (complex_else_if -> simple_else_if .)
    LET             reduce using rule 83 (complex_else_if -> simple_else_if .)
    FOR             reduce using rule 83 (complex_else_if -> simple_else_if .)
    WHILE           reduce using rule 83 (complex_else_if -> simple_else_if .)
    IF              reduce using rule 83 (complex_else_if -> simple_else_if .)
    $end            reduce using rule 83 (complex_else_if -> simple_else_if .)
    R_BRACE         reduce using rule 83 (complex_else_if -> simple_else_if .)


state 196

    (14) block -> ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE . ignored_newlines
    (110) ignored_newlines -> . empty
    (111) ignored_newlines -> . NEWLINE ignored_newlines
    (112) empty -> .
    NEWLINE         shift and go to state 4
    RETURN          reduce using rule 112 (empty -> .)
    ID              reduce using rule 112 (empty -> .)
    WRITE_FILE      reduce using rule 112 (empty -> .)
    PRINT           reduce using rule 112 (empty -> .)
    LET             reduce using rule 112 (empty -> .)
    FOR             reduce using rule 112 (empty -> .)
    WHILE           reduce using rule 112 (empty -> .)
    IF              reduce using rule 112 (empty -> .)
    $end            reduce using rule 112 (empty -> .)
    R_BRACE         reduce using rule 112 (empty -> .)
    ELSE_IF         reduce using rule 112 (empty -> .)
    ELSE            reduce using rule 112 (empty -> .)

    ignored_newlines               shift and go to state 201
    empty                          shift and go to state 3

state 197

    (16) block_1 -> statement block_1 .
    R_BRACE         reduce using rule 16 (block_1 -> statement block_1 .)


state 198

    (91) func_params_1 -> ID COLON const_type COMMA func_params_1 .
    R_PAREN         reduce using rule 91 (func_params_1 -> ID COLON const_type COMMA func_params_1 .)


state 199

    (88) func -> LET ID L_PAREN func_params R_PAREN COLON func_type block .
    RETURN          reduce using rule 88 (func -> LET ID L_PAREN func_params R_PAREN COLON func_type block .)
    ID              reduce using rule 88 (func -> LET ID L_PAREN func_params R_PAREN COLON func_type block .)
    WRITE_FILE      reduce using rule 88 (func -> LET ID L_PAREN func_params R_PAREN COLON func_type block .)
    PRINT           reduce using rule 88 (func -> LET ID L_PAREN func_params R_PAREN COLON func_type block .)
    LET             reduce using rule 88 (func -> LET ID L_PAREN func_params R_PAREN COLON func_type block .)
    FOR             reduce using rule 88 (func -> LET ID L_PAREN func_params R_PAREN COLON func_type block .)
    WHILE           reduce using rule 88 (func -> LET ID L_PAREN func_params R_PAREN COLON func_type block .)
    IF              reduce using rule 88 (func -> LET ID L_PAREN func_params R_PAREN COLON func_type block .)
    $end            reduce using rule 88 (func -> LET ID L_PAREN func_params R_PAREN COLON func_type block .)
    R_BRACE         reduce using rule 88 (func -> LET ID L_PAREN func_params R_PAREN COLON func_type block .)


state 200

    (75) for_loop -> FOR L_PAREN var SEMICOLON expr SEMICOLON assign R_PAREN . block
    (14) block -> . ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines
    (110) ignored_newlines -> . empty
    (111) ignored_newlines -> . NEWLINE ignored_newlines
    (112) empty -> .
    NEWLINE         shift and go to state 4
    L_BRACE         reduce using rule 112 (empty -> .)

    block                          shift and go to state 202
    ignored_newlines               shift and go to state 122
    empty                          shift and go to state 3

state 201

    (14) block -> ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines .
    RETURN          reduce using rule 14 (block -> ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines .)
    ID              reduce using rule 14 (block -> ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines .)
    WRITE_FILE      reduce using rule 14 (block -> ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines .)
    PRINT           reduce using rule 14 (block -> ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines .)
    LET             reduce using rule 14 (block -> ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines .)
    FOR             reduce using rule 14 (block -> ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines .)
    WHILE           reduce using rule 14 (block -> ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines .)
    IF              reduce using rule 14 (block -> ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines .)
    $end            reduce using rule 14 (block -> ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines .)
    R_BRACE         reduce using rule 14 (block -> ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines .)
    ELSE_IF         reduce using rule 14 (block -> ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines .)
    ELSE            reduce using rule 14 (block -> ignored_newlines L_BRACE ignored_newlines block_1 R_BRACE ignored_newlines .)


state 202

    (75) for_loop -> FOR L_PAREN var SEMICOLON expr SEMICOLON assign R_PAREN block .
    RETURN          reduce using rule 75 (for_loop -> FOR L_PAREN var SEMICOLON expr SEMICOLON assign R_PAREN block .)
    ID              reduce using rule 75 (for_loop -> FOR L_PAREN var SEMICOLON expr SEMICOLON assign R_PAREN block .)
    WRITE_FILE      reduce using rule 75 (for_loop -> FOR L_PAREN var SEMICOLON expr SEMICOLON assign R_PAREN block .)
    PRINT           reduce using rule 75 (for_loop -> FOR L_PAREN var SEMICOLON expr SEMICOLON assign R_PAREN block .)
    LET             reduce using rule 75 (for_loop -> FOR L_PAREN var SEMICOLON expr SEMICOLON assign R_PAREN block .)
    FOR             reduce using rule 75 (for_loop -> FOR L_PAREN var SEMICOLON expr SEMICOLON assign R_PAREN block .)
    WHILE           reduce using rule 75 (for_loop -> FOR L_PAREN var SEMICOLON expr SEMICOLON assign R_PAREN block .)
    IF              reduce using rule 75 (for_loop -> FOR L_PAREN var SEMICOLON expr SEMICOLON assign R_PAREN block .)
    $end            reduce using rule 75 (for_loop -> FOR L_PAREN var SEMICOLON expr SEMICOLON assign R_PAREN block .)
    R_BRACE         reduce using rule 75 (for_loop -> FOR L_PAREN var SEMICOLON expr SEMICOLON assign R_PAREN block .)
